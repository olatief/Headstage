C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE INCDIR(..\usb_rx;..\..\compiler\c51;..\..\hal\nrf24lu1p
                    -;..\..\hal\nrf24l01p) DEFINE(MCU_NRF24LU1P) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PREPRINT

line level    source

   1          #include <Nordic\reg24lu1.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1   * reg24lu1.h
   3      =1   *
   4      =1   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =1   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =1   *
   7      =1   *
   8      =1   *------------------------------------------------------------------------*/
   9      =1  #ifndef __REG24LU1_H__
  10      =1  #define __REG24LU1_H__
  11      =1  
  12      =1  //-----------------------------------------------------------------------------
  13      =1  // Byte Registers
  14      =1  //-----------------------------------------------------------------------------
  15      =1  
  16      =1  sfr   P0           = 0x80;
  17      =1  sfr   SP           = 0x81;
  18      =1  sfr   DPL          = 0x82;
  19      =1  sfr   DPH          = 0x83;
  20      =1  sfr   DPL1         = 0x84;
  21      =1  sfr   DPH1         = 0x85;
  22      =1  sfr   PCON         = 0x87;
  23      =1  sfr   TCON         = 0x88;
  24      =1  sfr   TMOD         = 0x89;
  25      =1  sfr   TL0          = 0x8A;
  26      =1  sfr   TL1          = 0x8B;
  27      =1  sfr   TH0          = 0x8C;
  28      =1  sfr   TH1          = 0x8D;
  29      =1  sfr   CKCON        = 0x8E;
  30      =1  sfr   RFCON        = 0x90;
  31      =1  sfr   DPS          = 0x92;
  32      =1  sfr   P0DIR        = 0x94;
  33      =1  sfr   P0ALT        = 0x95;
  34      =1  sfr   S0CON        = 0x98;
  35      =1  sfr   S0BUF        = 0x99;
  36      =1  sfr   IEN2         = 0x9A;
  37      =1  sfr   USBCON       = 0xA0;
  38      =1  sfr   CLKCTL       = 0xA3;
  39      =1  sfr   PWRDWN       = 0xA4;
  40      =1  sfr   WUCONF       = 0xA5;
  41      =1  sfr   INTEXP       = 0xA6;
  42      =1  sfr   IEN0         = 0xA8;
  43      =1  sfr   IP0          = 0xA9;
  44      =1  sfr   S0RELL       = 0xAA;
  45      =1  sfr   REGXH        = 0xAB;
  46      =1  sfr   REGXL        = 0xAC;
  47      =1  sfr   REGXC        = 0xAD;
  48      =1  sfr   RSTRES       = 0xB1;
  49      =1  sfr   SMDAT        = 0xB2;
  50      =1  sfr   SMCTL        = 0xB3;
  51      =1  sfr   TICKDV       = 0xB5;
  52      =1  sfr   IEN1         = 0xB8;
  53      =1  sfr   IP1          = 0xB9;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 2   

  54      =1  sfr   S0RELH       = 0xBA;
  55      =1  sfr   SSCONF       = 0xBC;
  56      =1  sfr   SSDATA       = 0xBD;
  57      =1  sfr   SSSTAT       = 0xBE;
  58      =1  sfr   IRCON        = 0xC0;
  59      =1  sfr   CCEN         = 0xC1;
  60      =1  sfr   CCL1         = 0xC2;
  61      =1  sfr   CCH1         = 0xC3;
  62      =1  sfr   CCL2         = 0xC4;
  63      =1  sfr   CCH2         = 0xC5;
  64      =1  sfr   CCL3         = 0xC6;
  65      =1  sfr   CCH3         = 0xC7;
  66      =1  sfr   T2CON        = 0xC8;
  67      =1  sfr   P0EXP        = 0xC9;
  68      =1  sfr   CRCL         = 0xCA;
  69      =1  sfr   CRCH         = 0xCB;
  70      =1  sfr   TL2          = 0xCC;
  71      =1  sfr   TH2          = 0xCD;
  72      =1  sfr   PSW          = 0xD0;
  73      =1  sfr   WDCON        = 0xD8;
  74      =1  sfr   USBSLP       = 0xD9;
  75      =1  sfr   ACC          = 0xE0;
  76      =1  sfr   RFDAT        = 0xE5;
  77      =1  sfr   RFCTL        = 0xE6;
  78      =1  sfr   AESCS        = 0xE8;
  79      =1  sfr   MD0          = 0xE9;
  80      =1  sfr   MD1          = 0xEA;
  81      =1  sfr   MD2          = 0xEB;
  82      =1  sfr   MD3          = 0xEC;
  83      =1  sfr   MD4          = 0xED;
  84      =1  sfr   MD5          = 0xEE;
  85      =1  sfr   ARCON        = 0xEF;
  86      =1  sfr   B            = 0xF0;
  87      =1  sfr   AESKIN       = 0xF1;
  88      =1  sfr   AESIV        = 0xF2;
  89      =1  sfr   AESD         = 0xF3;
  90      =1  sfr   AESIA1       = 0xF5;
  91      =1  sfr   AESIA2       = 0xF6;
  92      =1  sfr   FSR          = 0xF8;
  93      =1  sfr   FPCR         = 0xF9;
  94      =1  sfr   FCR          = 0xFA;
  95      =1  
  96      =1  //-----------------------------------------------------------------------------
  97      =1  // Word Registers
  98      =1  //-----------------------------------------------------------------------------
  99      =1  
 100      =1  sfr16 CC1          = 0xC2;
 101      =1  sfr16 CC2          = 0xC4;
 102      =1  sfr16 CC3          = 0xC6;
 103      =1  sfr16 CRC          = 0xCA;
 104      =1  sfr16 T2           = 0xCC;
 105      =1  
 106      =1  //-----------------------------------------------------------------------------
 107      =1  /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
 108      =1     This causes errors due to the strong type checking of _Bool (and thereby bool) that
 109      =1     is turned on in our implementation of stdbool.h.
 110      =1     Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
 111      =1  */
 112      =1  
 113      =1  /*lint -e18 */
 114      =1  //-----------------------------------------------------------------------------
 115      =1  
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 3   

 116      =1  //-----------------------------------------------------------------------------
 117      =1  // Bit Definitions
 118      =1  //-----------------------------------------------------------------------------
 119      =1  
 120      =1  /*  FSR  */
 121      =1  sbit  MCDIS        = FSR^7;
 122      =1  sbit  STP          = FSR^6;
 123      =1  sbit  WEN          = FSR^5;
 124      =1  sbit  RDYN         = FSR^4;
 125      =1  sbit  INFEN        = FSR^3;
 126      =1  sbit  RDIS         = FSR^2;
 127      =1  sbit  RDEND        = FSR^1;
 128      =1  sbit  WPEN         = FSR^0;
 129      =1  
 130      =1  /*  PSW   */
 131      =1  sbit  CY           = PSW^7;
 132      =1  sbit  AC           = PSW^6;
 133      =1  sbit  F0           = PSW^5;
 134      =1  sbit  RS1          = PSW^4;
 135      =1  sbit  RS0          = PSW^3;
 136      =1  sbit  OV           = PSW^2;
 137      =1  sbit  F1           = PSW^1;
 138      =1  sbit  P            = PSW^0;
 139      =1  
 140      =1  /*  TCON  */
 141      =1  sbit  TF1          = TCON^7;
 142      =1  sbit  TR1          = TCON^6;
 143      =1  sbit  TF0          = TCON^5;
 144      =1  sbit  TR0          = TCON^4;
 145      =1  sbit  IE1          = TCON^3;
 146      =1  sbit  IT1          = TCON^2;
 147      =1  sbit  IE0          = TCON^1;
 148      =1  sbit  IT0          = TCON^0;
 149      =1  
 150      =1  /*  S0CON  */
 151      =1  sbit  SM0          = S0CON^7;
 152      =1  sbit  SM1          = S0CON^6;
 153      =1  sbit  SM20         = S0CON^5;
 154      =1  sbit  REN0         = S0CON^4;
 155      =1  sbit  TB80         = S0CON^3;
 156      =1  sbit  RB80         = S0CON^2;
 157      =1  sbit  TI0          = S0CON^1;
 158      =1  sbit  RI0          = S0CON^0;
 159      =1  
 160      =1  /*  T2CON  */
 161      =1  sbit  T2PS         = T2CON^7;
 162      =1  sbit  I3FR         = T2CON^6;
 163      =1  sbit  I2FR         = T2CON^5;
 164      =1  sbit  T2R1         = T2CON^4;
 165      =1  sbit  T2R0         = T2CON^3;
 166      =1  sbit  T2CM         = T2CON^2;
 167      =1  sbit  T2I1         = T2CON^1;
 168      =1  sbit  T2I0         = T2CON^0;
 169      =1  
 170      =1  /*  IEN0  */
 171      =1  sbit  EA           = IEN0^7;
 172      =1  
 173      =1  sbit  ET2          = IEN0^5;
 174      =1  sbit  ES0          = IEN0^4;
 175      =1  sbit  ET1          = IEN0^3;
 176      =1  sbit  EX1          = IEN0^2;
 177      =1  sbit  ET0          = IEN0^1;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 4   

 178      =1  sbit  EX0          = IEN0^0;
 179      =1  
 180      =1  /* IEN1  */
 181      =1  sbit  EXEN2        = IEN1^7;
 182      =1  
 183      =1  sbit  WUIRQ        = IEN1^5;
 184      =1  sbit  USB          = IEN1^4;
 185      =1  sbit  USBWU        = IEN1^3;
 186      =1  sbit  SPI          = IEN1^2;
 187      =1  sbit  RF           = IEN1^1;
 188      =1  sbit  RFSPI        = IEN1^0;
 189      =1  
 190      =1  /* IRCON */
 191      =1  sbit  EXF2         = IRCON^7;
 192      =1  sbit  TF2          = IRCON^6;
 193      =1  sbit  WUF          = IRCON^5;
 194      =1  sbit  USBF         = IRCON^4;
 195      =1  sbit  USBWUF       = IRCON^3;
 196      =1  sbit  SPIF         = IRCON^2;
 197      =1  sbit  RFF          = IRCON^1;
 198      =1  sbit  RFSPIF       = IRCON^0;
 199      =1  
 200      =1  /* USBCON */
 201      =1  sbit  SWRST        = USBCON^7;
 202      =1  sbit  WU           = USBCON^6;
 203      =1  sbit  SUSPEND      = USBCON^5;
 204      =1  sbit  IV4          = USBCON^4;
 205      =1  sbit  IV3          = USBCON^3;
 206      =1  sbit  IV2          = USBCON^2;
 207      =1  sbit  IV1          = USBCON^1;
 208      =1  sbit  IV0          = USBCON^0;
 209      =1  
 210      =1  /* PORT0 */
 211      =1  sbit  P00          = P0^0;
 212      =1  sbit  P01          = P0^1;
 213      =1  sbit  P02          = P0^2;
 214      =1  sbit  P03          = P0^3;
 215      =1  sbit  MCSN         = P0^3;
 216      =1  sbit  SCSN         = P0^3;
 217      =1  sbit  P04          = P0^4;
 218      =1  sbit  P05          = P0^5;
 219      =1  
 220      =1  /* RFCON */
 221      =1  sbit  RFCE         = RFCON^0;
 222      =1  sbit  RFCSN        = RFCON^1;
 223      =1  sbit  RFCKEN       = RFCON^2;
 224      =1  
 225      =1  /* WDCON */
 226      =1  sbit  BD           = WDCON^7;
 227      =1  
 228      =1  /* AESCS */
 229      =1  sbit  GO           = AESCS^0;
 230      =1  sbit  DECR         = AESCS^1;
 231      =1  
 232      =1  /*lint +e18 */  /* Re-enable Lint warning 18 */
 233      =1  
 234      =1  
 235      =1  /* REGX commands */
 236      =1  #define RWD         0x00
 237      =1  #define WWD         0x08
 238      =1  #define RGTIMER     0x01
 239      =1  #define WGTIMER     0x09
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 5   

 240      =1  #define RRTCLAT     0x02
 241      =1  #define WRTCLAT     0x0A
 242      =1  #define RRTC        0x03
 243      =1  #define WRTCDIS     0x0B
 244      =1  #define RWSTA0      0x04
 245      =1  #define WWCON0      0x0C
 246      =1  #define RWSTA1      0x05
 247      =1  #define WWCON1      0x0D
 248      =1  
 249      =1  //-----------------------------------------------------------------------------
 250      =1  // Interrupt Vector Definitions
 251      =1  //-----------------------------------------------------------------------------
 252      =1  
 253      =1  #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
 254      =1  #define INTERRUPT_T0           1   // Timer0 Overflow
 255      =1  #define INTERRUPT_AES_RDY      2   // AES ready interrupt
 256      =1  #define INTERRUPT_T1           3   // Timer1 Overflow
 257      =1  #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
 258      =1  #define INTERRUPT_T2           5   // Timer2 Overflow
 259      =1  #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
 260      =1  #define INTERRUPT_RFIRQ        9   // RF interrupt
 261      =1  #define INTERRUPT_SPI          10  // SPI interrupt
 262      =1  #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
 263      =1  #define INTERRUPT_USB_INT      12  // USB interrupt
 264      =1  #define INTERRUPT_WU           13  // Internal wakeup interrupt
 265      =1  
 266      =1  //-----------------------------------------------------------------------------
 267      =1  // Header File Preprocessor Directive
 268      =1  //-----------------------------------------------------------------------------
 269      =1  
 270      =1  #endif
   2          #include <intrins.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  INTRINS.H
   3      =1  
   4      =1  Intrinsic functions for C51.
   5      =1  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __INTRINS_H__
  10      =1  #define __INTRINS_H__
  11      =1  
  12      =1  extern void          _nop_     (void);
  13      =1  extern bit           _testbit_ (bit);
  14      =1  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =1  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =1  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =1  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =1  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =1  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =1  extern unsigned char _chkfloat_(float);
  21      =1  #if !defined (__CX2__)
  22      =1  extern void          _push_    (unsigned char _sfr);
  23      =1  extern void          _pop_     (unsigned char _sfr);
  24      =1  #endif
  25      =1  
  26      =1  #endif
  27      =1  
   3          #include <stdint.h>
   1      =1  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 6   

   3      =1   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =1   * Terms and conditions of usage are described in detail in NORDIC
   5      =1   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *
  11      =1   * $LastChangedRevision: 4726 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =1   *
  17      =1   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =1   * interpreted in the same way by the compiler. The types here are defined by their
  19      =1   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =1   * between the name and properties of the storage class should be true, regardless of
  21      =1   * the compiler being used.
  22      =1   */
  23      =1  
  24      =1  #ifndef __STDINT_H__
  25      =1  #define __STDINT_H__
  26      =1  
  27      =1  #ifdef __C51__
  28      =1  
  29      =1  typedef unsigned char uint8_t;        ///< 8 bit unsigned int
  30      =1  
  31      =1  typedef signed char int8_t;          ///< 8 bit signed int
  32      =1  
  33      =1  typedef unsigned int uint16_t;        ///< 16 bit unsigned int
  34      =1  
  35      =1  typedef signed int int16_t;          ///< 16 bit signed int
  36      =1  
  37      =1  typedef unsigned long uint32_t;       ///< 32 bit unsigned int
  38      =1  
  39      =1  typedef signed long int32_t;         ///< 32 bit signed int
  40      =1  
  41      =1  #endif // __C51__
  42      =1  
  43      =1  #ifndef NULL
  44      =1  #define NULL (void*)0
  45      =1  #endif
  46      =1  
  47      =1  #endif // __STDINT_H__
   4          #include <stdio.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 7   

           =1  #define NULL ((void *) 0)
           =1 #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
  43      =1  
   5          
   6          #include "usb.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */ 
  13      =1  
  14      =1  /** @file
  15      =1   * @brief This file contain definitions related to the USB-controller and internal structures
  16      =1   */
  17      =1  
  18      =1  #ifndef USB_H__
  19      =1  #define USB_H__
  20      =1  
  21      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 8   

  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  22      =1  
  23      =1  #include "hal_usb.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 5717 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * @brief Interface for the USB device controller.
  16      =2   *
  17      =2   * The header file must define the following type defined structs:
  18      =2   *  - hal_usb_conf_desc_templ_t
  19      =2   *  - hal_usb_string_desc_templ_t
  20      =2   *  - hal_usb_dev_desc_templ_t
  21      =2   *  .
  22      =2   * And the following global variables:
  23      =2   *  - g_usb_string_desc
  24      =2   *  - g_usb_conf_desc
  25      =2   *  - g_usb_dev_desc
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 9   

  26      =2   *
  27      =2   * @defgroup hal_nrf24lu1p_hal_usb Universal Serial Bus (hal_usb)
  28      =2   * @{
  29      =2   * @ingroup hal_nrf24lu1p
  30      =2   *
  31      =2   * <h1>Control Transfer Functionality</h1>
  32      =2   *
  33      =2   * <h2>Descriptor Requests</h2>
  34      =2   * The module handles the following <b>descriptor requests</b>:
  35      =2   * - Device
  36      =2   * - Configuration
  37      =2   * - String
  38      =2   *
  39      =2   * It does <b>not</b> support (replies with STALL to USB host controller):
  40      =2   * - Interface
  41      =2   * - DeviceQual
  42      =2   * - OtherSpeedConf
  43      =2   * - InterfacePower
  44      =2   * 
  45      =2   * All other descriptor requests (HID, ...) are made available to the application code through the hal_usb
             -_cb_device_req_t callback.
  46      =2   *
  47      =2   * The module do <b>not</b> support SetDescriptor requests
  48      =2   *
  49      =2   * <h2>Feature Requests</h2>
  50      =2   *
  51      =2   * The module handles the following feature requests:
  52      =2   * -  DeviceRemoteWakeup
  53      =2   * -  EndpointHalt
  54      =2   * 
  55      =2   * It does <b>not</b> support (replies with STALL to USB host controller) any other feature requests yet
  56      =2   *
  57      =2   * <h2>Configuration Requests</h2>
  58      =2   *
  59      =2   * The module do only support setting configuration 0 (sets the adressed state) and 1. Other configuration
             -s replies with STALL. Several configurations for a device is not implemented.
  60      =2   * 
  61      =2   * <h2>Alternative Interface Requests</h2>
  62      =2   *
  63      =2   * Setting and getting alternative interfaces are not supported (replies with STALL to USB host controller
             -)
  64      =2   * 
  65      =2   * <h2>Sync Frame Requests</h2>
  66      =2   * Not supported
  67      =2   * 
  68      =2   * <h2>Class Specific Requests</h2>
  69      =2   * All class specific requests are made available to the application code through the hal_usb_cb_device_re
             -q_t callback. 
  70      =2   *
  71      =2   * <h1>Endpoint Functionality</h1>
  72      =2   * All available IN and OUT endpoints are avialable to the application through the hal_usb_send_packet, ha
             -l_usb_receive_packet functions and the callbacks registered for the endpoint. The callback functions are called when the
             - host replies with an ACK for having received a packet or when the host has sent an OUT packet. 
  73      =2   * 
  74      =2   * Isochronos endpoints are not supported in this version of USB HAL.
  75      =2   */
  76      =2  
  77      =2  #ifndef HAL_USB_H__
  78      =2  #define HAL_USB_H__
  79      =2  
  80      =2  #include <stdint.h>
   1      =3  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 10  

   2      =3   *
   3      =3   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =3   * Terms and conditions of usage are described in detail in NORDIC
   5      =3   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *
  11      =3   * $LastChangedRevision: 4726 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =3   *
  17      =3   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =3   * interpreted in the same way by the compiler. The types here are defined by their
  19      =3   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =3   * between the name and properties of the storage class should be true, regardless of
  21      =3   * the compiler being used.
  22      =3   */
  23      =3  
  24      =3  #ifndef __STDINT_H__
           =3 #define __STDINT_H__
           =3 
           =3 #ifdef __C51__
           =3 
           =3 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =3 
           =3 typedef signed char int8_t;          ///< 8 bit signed int
           =3 
           =3 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =3 
           =3 typedef signed int int16_t;          ///< 16 bit signed int
           =3 
           =3 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =3 
           =3 typedef signed long int32_t;         ///< 32 bit signed int
           =3 
           =3 #endif // __C51__
           =3 
           =3 #ifndef NULL
           =3 #define NULL (void*)0
           =3 #endif
           =3 
           =3 #endif // __STDINT_H__
  81      =2  #include <stdbool.h>
   1      =3  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
   3      =3   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =3   * Terms and conditions of usage are described in detail in NORDIC
   5      =3   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *
  11      =3   * $LastChangedRevision: 4726 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Type definitions for firmware projects developed at Nordic semiconductor.
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 11  

  16      =3   *
  17      =3   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =3   * interpreted in the same way by the compiler. The types here are defined by their
  19      =3   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =3   * between the name and properties of the storage class should be true, regardless of
  21      =3   * the compiler being used.
  22      =3   */
  23      =3  
  24      =3  #ifndef __STDBOOL_H__
  25      =3  #define __STDBOOL_H__
  26      =3  
  27      =3  //lint -strong(B,_Bool)
  28      =3  typedef unsigned char _Bool; ///< Boolean type
  29      =3  
  30      =3  #define bool _Bool
  31      =3  #define true 1
  32      =3  #define false 0
  33      =3  #define __bool_true_false_are_defined 1
  34      =3  
  35      =3  #endif // __STDBOOL_H__
  82      =2  
  83      =2  #include "config.h" 
   1      =3  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
   3      =3   * The information contained herein is confidential property of Nordic 
   4      =3   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =3   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *              
  11      =3   * $LastChangedRevision: 5718 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Configuration file for bootloader
  16      =3   *
  17      =3   */
  18      =3  #ifndef CONFIG_H__
  19      =3  #define CONFIG_H__
  20      =3  
  21      =3  #define FLASH_PAGE_SIZE     512U
  22      =3  #define MAX_PACKET_SIZE_EP0 32
  23      =3  #define USB_EP1_SIZE        64
  24      =3  #define FLASH_SIZE          (32U*1024U)
  25      =3  #define NUM_FLASH_PAGES     FLASH_SIZE/FLASH_PAGE_SIZE
  26      =3  
  27      =3  #endif // CONFIG_H__
  84      =2  #include "usb_desc_bulk.h"
   1      =3  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
   3      =3   * The information contained herein is confidential property of Nordic 
   4      =3   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =3   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *              
  11      =3   * $LastChangedRevision: 5718 $
  12      =3   */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 12  

  13      =3  
  14      =3  /** @file
  15      =3   * Header file for the Bootloader USB descriptor
  16      =3   *
  17      =3   */
  18      =3  #ifndef USB_DESC_BULK_H__
  19      =3  #define USB_DESC_BULK_H__
  20      =3  
  21      =3  #include "hal_usb_desc.h"
   1      =4  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =4   *
   3      =4   * The information contained herein is confidential property of Nordic 
   4      =4   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =4   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =4   *
   7      =4   * Licensees are granted free, non-transferable use of the information. NO
   8      =4   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =4   * the file.
  10      =4   *              
  11      =4   * $LastChangedRevision: 5717 $
  12      =4   */
  13      =4  
  14      =4  /** @file
  15      =4  * @brief This file contain structures and constants defined in Chapter 9 of the USB 2.0 standard
  16      =4   */
  17      =4  
  18      =4  #ifndef HAL_USB_DESC_H__
  19      =4  #define HAL_USB_DESC_H__
  20      =4  
  21      =4  #include <stdint.h>
   1      =5  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =5   *
   3      =5   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =5   * Terms and conditions of usage are described in detail in NORDIC
   5      =5   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =5   *
   7      =5   * Licensees are granted free, non-transferable use of the information. NO
   8      =5   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =5   * the file.
  10      =5   *
  11      =5   * $LastChangedRevision: 4726 $
  12      =5   */
  13      =5  
  14      =5  /** @file
  15      =5   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =5   *
  17      =5   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =5   * interpreted in the same way by the compiler. The types here are defined by their
  19      =5   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =5   * between the name and properties of the storage class should be true, regardless of
  21      =5   * the compiler being used.
  22      =5   */
  23      =5  
  24      =5  #ifndef __STDINT_H__
           =5 #define __STDINT_H__
           =5 
           =5 #ifdef __C51__
           =5 
           =5 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =5 
           =5 typedef signed char int8_t;          ///< 8 bit signed int
           =5 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 13  

           =5 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =5 
           =5 typedef signed int int16_t;          ///< 16 bit signed int
           =5 
           =5 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =5 
           =5 typedef signed long int32_t;         ///< 32 bit signed int
           =5 
           =5 #endif // __C51__
           =5 
           =5 #ifndef NULL
           =5 #define NULL (void*)0
           =5 #endif
           =5 
           =5 #endif // __STDINT_H__
  22      =4  
  23      =4  // Standard request codes
  24      =4  #define USB_REQ_GET_STATUS         0x00
  25      =4  #define USB_REQ_CLEAR_FEATURE      0x01
  26      =4  #define USB_REQ_RESERVED_1         0x02
  27      =4  #define USB_REQ_SET_FEATURE        0x03
  28      =4  #define USB_REQ_RESERVED_2         0x04
  29      =4  #define USB_REQ_SET_ADDRESS        0x05
  30      =4  #define USB_REQ_GET_DESCRIPTOR     0x06
  31      =4  #define USB_REQ_SET_DESCRIPTOR     0x07
  32      =4  #define USB_REQ_GET_CONFIGURATION  0x08
  33      =4  #define USB_REQ_SET_CONFIGURATION  0x09
  34      =4  #define USB_REQ_GET_INTERFACE      0x0a
  35      =4  #define USB_REQ_SET_INTERFACE      0x0b
  36      =4  #define USB_REQ_SYNCH_FRAME        0x0c
  37      =4  
  38      =4  // Descriptor types
  39      =4  #define USB_DESC_DEVICE           0x01
  40      =4  #define USB_DESC_CONFIGURATION    0x02
  41      =4  #define USB_DESC_STRING           0x03
  42      =4  #define USB_DESC_INTERFACE        0x04
  43      =4  #define USB_DESC_ENDPOINT         0x05
  44      =4  #define USB_DESC_DEVICE_QUAL      0x06
  45      =4  #define USB_DESC_OTHER_SPEED_CONF 0x07
  46      =4  #define USB_DESC_INTERFACE_POWER  0x08
  47      =4  #define USB_DESC_OTG              0x09
  48      =4  #define USB_DESC_DEBUG            0x0A
  49      =4  #define USB_DESC_INTERFACE_ASSOC  0x0B
  50      =4  
  51      =4  #define USB_ENDPOINT_TYPE_CONTROL           0x00
  52      =4  #define USB_ENDPOINT_TYPE_ISOCHRONOUS       0x01
  53      =4  #define USB_ENDPOINT_TYPE_BULK              0x02
  54      =4  #define USB_ENDPOINT_TYPE_INTERRUPT         0x03
  55      =4  
  56      =4  // USB device classes
  57      =4  #define USB_DEVICE_CLASS_RESERVED               0x00
  58      =4  #define USB_DEVICE_CLASS_AUDIO                  0x01
  59      =4  #define USB_DEVICE_CLASS_COMMUNICATIONS         0x02
  60      =4  #define USB_DEVICE_CLASS_HUMAN_INTERFACE        0x03
  61      =4  #define USB_DEVICE_CLASS_MONITOR                0x04
  62      =4  #define USB_DEVICE_CLASS_PHYSICAL_INTERFACE     0x05
  63      =4  #define USB_DEVICE_CLASS_POWER                  0x06
  64      =4  #define USB_DEVICE_CLASS_PRINTER                0x07
  65      =4  #define USB_DEVICE_CLASS_STORAGE                0x08
  66      =4  #define USB_DEVICE_CLASS_HUB                    0x09
  67      =4  #define USB_DEVICE_CLASS_APPLICATION_SPECIFIC   0xFE
  68      =4  #define USB_DEVICE_CLASS_VENDOR_SPECIFIC        0xFF
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 14  

  69      =4  
  70      =4  
  71      =4  #define USB_CLASS_DESCRIPTOR_HID    0x21
  72      =4  #define USB_CLASS_DESCRIPTOR_REPORT 0x22
  73      =4  #define USB_CLASS_DESCRIPTOR_PHYSICAL_DESCRIPTOR 0x23
  74      =4  
  75      =4  #define USB_DEVICE_REMOTE_WAKEUP    0x01
  76      =4  #define USB_ENDPOINT_HALT           0x00
  77      =4  #define USB_TEST_MODE               0x02
  78      =4  
  79      =4  typedef struct {
  80      =4       volatile uint8_t bLength;
  81      =4       volatile uint8_t bDescriptorType;
  82      =4       volatile uint16_t bcdUSB;
  83      =4       volatile uint8_t bDeviceClass;
  84      =4       volatile uint8_t bDeviceSubClass;
  85      =4       volatile uint8_t bDeviceProtocol;
  86      =4       volatile uint8_t bMaxPacketSize0;
  87      =4       volatile uint16_t idVendor;
  88      =4       volatile uint16_t idProduct;
  89      =4       volatile uint16_t bcdDevice;
  90      =4       volatile uint8_t iManufacturer;
  91      =4       volatile uint8_t iProduct;
  92      =4       volatile uint8_t iSerialNumber;
  93      =4       volatile uint8_t bNumConfigurations;
  94      =4  } hal_usb_dev_desc_t;
  95      =4  
  96      =4  typedef struct {
  97      =4       volatile uint8_t bLength;
  98      =4       volatile uint8_t bDescriptorType;
  99      =4       volatile uint16_t wTotalLength;
 100      =4       volatile uint8_t bNumInterfaces;
 101      =4       volatile uint8_t bConfigurationValue;
 102      =4       volatile uint8_t iConfiguration;
 103      =4       volatile uint8_t bmAttributes;
 104      =4       volatile uint8_t bMaxPower;
 105      =4  } hal_usb_conf_desc_t;
 106      =4  
 107      =4  typedef struct {
 108      =4       volatile uint8_t bLength;
 109      =4       volatile uint8_t bDescriptorType;
 110      =4       volatile uint8_t bInterfaceNumber;
 111      =4       volatile uint8_t bAlternateSetting;
 112      =4       volatile uint8_t bNumEndpoints;
 113      =4       volatile uint8_t bInterfaceClass;
 114      =4       volatile uint8_t bInterfaceSubClass;
 115      =4       volatile uint8_t bInterfaceProtocol;
 116      =4       volatile uint8_t iInterface;
 117      =4  } hal_usb_if_desc_t;
 118      =4  
 119      =4  typedef struct {
 120      =4       volatile uint8_t bLength;
 121      =4       volatile uint8_t bDescriptorType;
 122      =4       volatile uint8_t bEndpointAddress;
 123      =4       volatile uint8_t bmAttributes;
 124      =4       volatile uint16_t wMaxPacketSize;
 125      =4       volatile uint8_t bInterval;
 126      =4  } hal_usb_ep_desc_t;
 127      =4  
 128      =4  /*
 129      =4  typedef struct {
 130      =4      volatile uint8_t bLength;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 15  

 131      =4      volatile uint8_t bDescriptorType;
 132      =4      volatile uint16_t bcdHID;
 133      =4      volatile uint8_t bCountryCode;
 134      =4      volatile uint8_t bNumDescriptors;
 135      =4      volatile uint8_t bDescriptorType2;
 136      =4      volatile uint16_t wDescriptorLength;
 137      =4  } hal_usb_hid_desc_t;
 138      =4  
 139      =4  
 140      =4  typedef struct {
 141      =4       volatile uint8_t* desc;
 142      =4  } hal_usb_string_desc_t;
 143      =4  
 144      =4  typedef struct {
 145      =4       volatile uint8_t bLength;
 146      =4       volatile uint8_t bDescriptorType;
 147      =4  } hal_usb_common_desc_t;
 148      =4    */
 149      =4  
 150      =4  #endif // HAL_USB_DESC_H__
  22      =3  
  23      =3  #define USB_DESC_TEMPLATE 
  24      =3  
  25      =3  //------------------------------------------ 
  26      =3  // Vendor ID and Product ID definitions 
  27      =3  //------------------------------------------ 
  28      =3  #define VID   0x1915 
  29      =3  #define PID   0x0909 
  30      =3  
  31      =3  #define USB_STRING_DESC_COUNT 2
  32      =3  
  33      =3  typedef struct
  34      =3  {
  35      =3      hal_usb_conf_desc_t conf;
  36      =3      hal_usb_if_desc_t if0;
  37      =3      hal_usb_ep_desc_t ep1in;
  38      =3      hal_usb_ep_desc_t ep1out;
  39      =3  } usb_conf_desc_templ_t;
  40      =3  
  41      =3  typedef struct { 
  42      =3       volatile uint8_t* idx[USB_STRING_DESC_COUNT]; 
  43      =3  } usb_string_desc_templ_t; 
  44      =3  
  45      =3  extern code usb_string_desc_templ_t g_usb_string_desc; 
  46      =3  extern code usb_conf_desc_templ_t g_usb_conf_desc;
  47      =3  extern code hal_usb_dev_desc_t g_usb_dev_desc;
  48      =3  
  49      =3  typedef struct { 
  50      =3       hal_usb_dev_desc_t* dev; 
  51      =3       usb_conf_desc_templ_t* conf; 
  52      =3       usb_string_desc_templ_t* string; 
  53      =3       uint8_t string_zero[4]; 
  54      =3  } usb_descs_templ_t;
  55      =3  
  56      =3  extern code uint8_t g_usb_string_desc_1[];
  57      =3  extern code uint8_t g_usb_string_desc_2[];
  58      =3  extern code uint8_t string_zero[4];
  59      =3  
  60      =3  #endif  // USB_DESC_TEMPL_H__
  85      =2  
  86      =2  #ifndef USB_DESC_TEMPLATE
           =2 #error "USB_DESC_TEMPLATE not defined. Please include a file with g_usb_string_desc, g_usb_conf_desc and g
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 16  

             -_usb_dev_desc defined" 
           =2 #endif
  89      =2  
  90      =2  #define USB_BM_STATE_CONFIGURED 0x01
  91      =2  #define USB_BM_STATE_ALLOW_REMOTE_WAKEUP 0x02
  92      =2  #define USB_BM_STATE_HOST_WU     0x04
  93      =2  
  94      =2  // Calculate buffer location in USB-controller
  95      =2  #define CALCULATE_BUF_IN_PTR(ep) (uint8_t xdata *)(in0buf - (( ep & 0x7f) * 128))
  96      =2  #define CALCULATE_BUF_OUT_PTR(ep) (uint8_t xdata *)(out0buf - (ep * 128 ))
  97      =2  
  98      =2  /** An enum describing the USB state
  99      =2   * 
 100      =2   *  The states described in this enum are found in Chapter 9 of the USB 2.0 specification
 101      =2   */
 102      =2  
 103      =2  typedef enum  { 
 104      =2      ATTACHED,   /**< Device is attached to the USB, but is not powered */
 105      =2      POWERED,    /**< Device is attached to the USB and powered */
 106      =2      DEFAULT,    /**< Device is attached to the USB and powered and has been reset, but has not been assign
             -ed a unique address */
 107      =2      ADDRESSED,  /**< Device is attached to the USB, powered, has been reset, and a unique device address h
             -as been assigned. Device is not configured */
 108      =2      CONFIGURED, /**< Device is attached to the USB, powered, has been reset, has a unique address, is conf
             -igured and is not suspended */
 109      =2      SUSPENDED   /**< Device is, at a minimum, attached to the USB and is powered and has not seen bus acti
             -vity for 3ms. It may also have a unique address and be configured for use. However, because the device is susended, the 
             -host may not use the device configuration */
 110      =2  } hal_usb_state_t;
 111      =2  
 112      =2  /** Structure containing the USB standard request
 113      =2   *  See Chapter 9 USB Device Framework in the USB 2.0 specification.
 114      =2   */
 115      =2  
 116      =2  typedef struct {
 117      =2      uint8_t  bmRequestType; /**< Bitmapped field identifying the characteristics of the request.
 118      =2                          - D7: Data transfer direction 
 119      =2                          - 0 = Host-to-device
 120      =2                          - 1 = Device-to-host
 121      =2  
 122      =2                          - D6..5: Type
 123      =2                          - 0 = Standard
 124      =2                          - 1 = Class
 125      =2                          - 2 = Vendor
 126      =2                          - 3 = Reserved
 127      =2  
 128      =2                          - D4..0: Recipient
 129      =2                          - 0 = Device
 130      =2                          - 1 = Interface
 131      =2                          - 2 = Endpoint
 132      =2                          - 3 = Other
 133      =2                          - 4..31 = Reserved
 134      =2                            */
 135      =2      uint8_t  bRequest;       /**< Field specifying request. bmRequestType(Type) modify the meaning of this
             - field. */
 136      =2  
 137      =2      uint8_t wValueMsb;      /**< Field used to pass a parameter to the device, specific to the request. MS
             -B*/
 138      =2      uint8_t wValueLsb;      /**< Field used to pass a parameter to the device, specific to the request. LS
             -B*/
 139      =2      uint8_t wIndex;         /**< Field used to pass a paramters to the device, specific to the request. */
 140      =2      uint8_t wLength;        /**< Field used to specify length of the data transferred during the second ph
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 17  

             -ase of the control transfer. Direction of data transfer given by bmRequestType(Direction). If field is zero there is no 
             -data transfer phase. */
 141      =2  //    void* misc_data;
 142      =2  } hal_usb_device_req;
 143      =2  
 144      =2  /** An enum describing what reply to send to the control request
 145      =2   */
 146      =2  
 147      =2  typedef enum {
 148      =2      STALL,         /**< Respond with STALL */
 149      =2      NAK,           /**< Respond with NAK   */
 150      =2      ACK,           /**< Respond with ACK (if this is an OUT request) */
 151      =2      NO_RESPONSE,   /**< Do not respond */
 152      =2      DATA,          /**< Data is available */
 153      =2      EMPTY_RESPONSE /**< Send an empty response */
 154      =2  } hal_usb_dev_req_resp_t;
 155      =2  
 156      =2  uint8_t ep_1_out_cb(uint8_t xdata *, uint8_t xdata *) reentrant;
 157      =2  /** Callback function that is called when a class request is received.
 158      =2   *  The type of class request is determined by the interface the request is for. If interface 1 is a HID i
             -nterface the request is a HID class request.
 159      =2   *  @param std_req The complete request. 
 160      =2   *  @param data_ptr Pointer to pointer to data(descriptor struct) the function wants to send back to USB-h
             -ost
 161      =2   *  @param size Size of data the function wants to send back to USB-host
 162      =2   */
 163      =2  
 164      =2  
 165      =2  typedef hal_usb_dev_req_resp_t (*hal_usb_cb_device_req_t)(hal_usb_device_req* device_req, uint8_t ** data_
             -ptr, uint8_t* size) reentrant;
 166      =2  
 167      =2  /** Callback function that is called when an endpoint interrupt occur 
 168      =2   *  @param adr_ptr IN endpoint: Pointer to address containing data to send. OUT endpoint: Pointer to addre
             -ss containg data received.
 169      =2   *  @param size IN endpoint: Number of bytes to send. OUT endpoint: number of bytes received.
 170      =2   *  @retval Bit 7 Set: STALL request
 171      =2   *  @retval Bit 6 Set: NACK request
 172      =2   *  @retval Bit 5..0 : Bytes to send
 173      =2   */
 174      =2  typedef uint8_t (*hal_usb_cb_endpoint_t)(uint8_t xdata *adr_ptr, uint8_t xdata *size) reentrant;
 175      =2  
 176      =2  /** Callback function that is called when a resume is signalled on the bus.
 177      =2   *  A resume is signalled by the Data K state. For full speed devices this is Differential "0". Differenti
             -al "0": D-> Voh(main) and D+ < Vol(max).
 178      =2   */
 179      =2  
 180      =2  typedef void (*hal_usb_cb_resume_t)();
 181      =2  
 182      =2  /** Callback function that is called when a suspend condition occur.
 183      =2   *  @param can_resume Set to 1 if the device is allowed to wake up the host controller
 184      =2   *  @see hal_usb_state_t
 185      =2   */
 186      =2  
 187      =2  typedef void (*hal_usb_cb_suspend_t)(uint8_t allow_remote_wu) reentrant;
 188      =2  
 189      =2  /** Callback function that is called when a reset condition occur.
 190      =2   *  
 191      =2   */
 192      =2  typedef void (*hal_usb_cb_reset_t)();
 193      =2  
 194      =2  /** A struct containing variables related to the USB HAL layer 
 195      =2   *  
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 18  

 196      =2   */
 197      =2  
 198      =2  typedef struct {
 199      =2      usb_descs_templ_t descs;     /**< Structure containing device, string and configuration descriptors fo
             -r a specific application */
 200      =2      uint8_t  bm_state;             /**< Bitmask containing USB state information: bitmask: 0 - is_hw_reset
             -, 1 - can signal remote wakeup, 2 - usb awake */
 201      =2      uint8_t current_config;        /**< Currently set configuration. If current_config is zero the device 
             -is not configured */
 202      =2      uint8_t current_alt_interface; /**< Currently alternative configuration. If a alternative configuratio
             -n is chosen the index of the alternative configuration is stored here. */
 203      =2      hal_usb_state_t state;       /**< Enum containing USB state information as described in Chapter 9 of t
             -he USB 2.0 specification.  */
 204      =2  
 205      =2      hal_usb_cb_device_req_t device_req;
 206      =2      hal_usb_cb_reset_t      reset;
 207      =2      hal_usb_cb_resume_t     resume;
 208      =2      hal_usb_cb_suspend_t    suspend;
 209      =2  } hal_usb_t;
 210      =2  
 211      =2  /** Function for setting up the USB controller and registering the callbacks 
 212      =2   *  @param usb_disconnect Set to true to perform physical disconnect and reconnect. Make sure to enable in
             -terruts as soon as possible after
 213      =2   *                        the call to this function.
 214      =2   *  @param device_req Pointer to function to call when a class specific request occur
 215      =2   *  @param reset Pointer to function to call when USB controller detect a reset
 216      =2   *  @param resume Pointer to function to call when USB controller detect a resume
 217      =2   *  @param suspend Pointer to function to call when USB controller detect a suspend
 218      =2   */
 219      =2  void hal_usb_init(
 220      =2      bool usb_disconnect,
 221      =2      hal_usb_cb_device_req_t device_req,
 222      =2      hal_usb_cb_reset_t      reset,
 223      =2      hal_usb_cb_resume_t     resume,
 224      =2      hal_usb_cb_suspend_t    suspend);
 225      =2  
 226      =2  /** Function to send a packet to host (IN endpoint)
 227      =2   *  @param ep_in_num IN endpointer number
 228      =2   *  @param buffer Pointer to buffer containing data to send
 229      =2   *  @param bytes_to_send Number of bytes to send.
 230      =2   */
 231      =2  void hal_usb_send_data(uint8_t data ep_in_num, uint8_t* data buffer, uint8_t data bytes_to_send);
 232      =2  
 233      =2  /** Function to register callbacks for given endpoints 
 234      =2   *  To register a callback one have to have a function with an argument list equal to usb_endpoint_cb_t.
 235      =2   *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
 236      =2   *  @param ep_size The maximum size of one packet for this endpoint
 237      =2   *  @param endpoint_isr Pointer to function that is called when host issues a request on the given endpoin
             -t. Set to 0 to unregister function.
 238      =2   */
 239      =2  void hal_usb_endpoint_config(uint8_t ep_num, uint8_t ep_size, hal_usb_cb_endpoint_t endpoint_isr);
 240      =2  
 241      =2  /** Function to stall or unstall an endpoint
 242      =2   *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
 243      =2   *  @param stall 1 - stall the endpoint. 0 - unstall the endpoint.
 244      =2   */
 245      =2  void hal_usb_endpoint_stall(uint8_t ep_num, bool stall);
 246      =2  
 247      =2  /** Function returning the current state of the USB controller
 248      =2   *  @see usb_stat_t
 249      =2   */
 250      =2  hal_usb_state_t hal_usb_get_state();
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 19  

 251      =2  
 252      =2  /** Function returning the assigned address for the device */
 253      =2  uint8_t hal_usb_get_address();
 254      =2  
 255      =2  /** Function to initiate a remote wakeup of the USB host */
 256      =2  void hal_usb_wakeup();
 257      =2  
 258      =2  /** Function to initiate a <b>hardware reset</b> of the USB-controller */
 259      =2  void hal_usb_reset();
 260      =2  
 261      =2  /** Function disconnecting the USB-controller from the USB bus  */
 262      =2  void hal_usb_bus_disconnect();
 263      =2  
 264      =2  /** Function connecting the USB-controller to the USB bus */
 265      =2  void hal_usb_bus_connect();
 266      =2  
 267      =2  /** Function stopping the clock to the usb controller or by other means powers it down */
 268      =2  void hal_usb_sleep();
 269      =2  
 270      =2  extern hal_usb_t g_hal_usb;
 271      =2  
 272      =2  #endif //  HAL_USB_H__
 273      =2  /** @} */
  24      =1  
  25      =1  #define USB_ENDPOINT_IN_COUNT 5
  26      =1  #define USB_ENDPOINT_OUT_COUNT 5
  27      =1  
  28      =1  #define USB_EP0_HSNAK() do { ep0cs = 0x02; } while(0)
  29      =1  #define USB_EP0_STALL() do { ep0cs = 0x11; } while(0) // Set both DSTALL and STALL when we want to stall a
             - request during a SETUP transaction
  30      =1  #define USB_EP0_DSTALL() do { ep0cs |= 0x10; } while(0)
  31      =1  
  32      =1  #define INT_SUDAV    0x00
  33      =1  #define INT_SOF      0x04
  34      =1  #define INT_SUTOK    0x08
  35      =1  #define INT_SUSPEND  0x0C
  36      =1  #define INT_USBRESET 0x10
  37      =1  #define INT_EP0IN    0x18
  38      =1  #define INT_EP0OUT   0x1C
  39      =1  #define INT_EP1IN    0x20
  40      =1  #define INT_EP1OUT   0x24
  41      =1  #define INT_EP2IN    0x28
  42      =1  #define INT_EP2OUT   0x2C
  43      =1  #define INT_EP3IN    0x30
  44      =1  #define INT_EP3OUT   0x34
  45      =1  #define INT_EP4IN    0x38
  46      =1  #define INT_EP4OUT   0x3C
  47      =1  #define INT_EP5IN    0x40
  48      =1  #define INT_EP5OUT   0x44
  49      =1  
  50      =1  #define BM_REQUEST_TYPE  0
  51      =1  #define B_REQUEST        1
  52      =1  #define W_VALUE          2
  53      =1  #define W_INDEX          4
  54      =1  #define W_LENGTH         6
  55      =1  
  56      =1  typedef struct
  57      =1  {
  58      =1      uint8_t *data_ptr;
  59      =1      uint8_t data_size;
  60      =1      uint8_t pkt_size;
  61      =1  } packetizer_t;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 20  

  62      =1  
  63      =1  #endif
   7          #include "hal_usb.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface for the USB device controller.
  16      =1   *
  17      =1   * The header file must define the following type defined structs:
  18      =1   *  - hal_usb_conf_desc_templ_t
  19      =1   *  - hal_usb_string_desc_templ_t
  20      =1   *  - hal_usb_dev_desc_templ_t
  21      =1   *  .
  22      =1   * And the following global variables:
  23      =1   *  - g_usb_string_desc
  24      =1   *  - g_usb_conf_desc
  25      =1   *  - g_usb_dev_desc
  26      =1   *
  27      =1   * @defgroup hal_nrf24lu1p_hal_usb Universal Serial Bus (hal_usb)
  28      =1   * @{
  29      =1   * @ingroup hal_nrf24lu1p
  30      =1   *
  31      =1   * <h1>Control Transfer Functionality</h1>
  32      =1   *
  33      =1   * <h2>Descriptor Requests</h2>
  34      =1   * The module handles the following <b>descriptor requests</b>:
  35      =1   * - Device
  36      =1   * - Configuration
  37      =1   * - String
  38      =1   *
  39      =1   * It does <b>not</b> support (replies with STALL to USB host controller):
  40      =1   * - Interface
  41      =1   * - DeviceQual
  42      =1   * - OtherSpeedConf
  43      =1   * - InterfacePower
  44      =1   * 
  45      =1   * All other descriptor requests (HID, ...) are made available to the application code through the hal_usb
             -_cb_device_req_t callback.
  46      =1   *
  47      =1   * The module do <b>not</b> support SetDescriptor requests
  48      =1   *
  49      =1   * <h2>Feature Requests</h2>
  50      =1   *
  51      =1   * The module handles the following feature requests:
  52      =1   * -  DeviceRemoteWakeup
  53      =1   * -  EndpointHalt
  54      =1   * 
  55      =1   * It does <b>not</b> support (replies with STALL to USB host controller) any other feature requests yet
  56      =1   *
  57      =1   * <h2>Configuration Requests</h2>
  58      =1   *
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 21  

  59      =1   * The module do only support setting configuration 0 (sets the adressed state) and 1. Other configuration
             -s replies with STALL. Several configurations for a device is not implemented.
  60      =1   * 
  61      =1   * <h2>Alternative Interface Requests</h2>
  62      =1   *
  63      =1   * Setting and getting alternative interfaces are not supported (replies with STALL to USB host controller
             -)
  64      =1   * 
  65      =1   * <h2>Sync Frame Requests</h2>
  66      =1   * Not supported
  67      =1   * 
  68      =1   * <h2>Class Specific Requests</h2>
  69      =1   * All class specific requests are made available to the application code through the hal_usb_cb_device_re
             -q_t callback. 
  70      =1   *
  71      =1   * <h1>Endpoint Functionality</h1>
  72      =1   * All available IN and OUT endpoints are avialable to the application through the hal_usb_send_packet, ha
             -l_usb_receive_packet functions and the callbacks registered for the endpoint. The callback functions are called when the
             - host replies with an ACK for having received a packet or when the host has sent an OUT packet. 
  73      =1   * 
  74      =1   * Isochronos endpoints are not supported in this version of USB HAL.
  75      =1   */
  76      =1  
  77      =1  #ifndef HAL_USB_H__
           =1 #define HAL_USB_H__
           =1 
           =1 #include <stdint.h>
           =1 #include <stdbool.h>
           =1 
           =1 #include "config.h" 
           =1 #include "usb_desc_bulk.h"
           =1 
           =1 #ifndef USB_DESC_TEMPLATE
           =1 #error "USB_DESC_TEMPLATE not defined. Please include a file with g_usb_string_desc, g_usb_conf_desc and g
             -_usb_dev_desc defined" 
           =1 #endif
           =1 
           =1 #define USB_BM_STATE_CONFIGURED 0x01
           =1 #define USB_BM_STATE_ALLOW_REMOTE_WAKEUP 0x02
           =1 #define USB_BM_STATE_HOST_WU     0x04
           =1 
           =1 // Calculate buffer location in USB-controller
           =1 #define CALCULATE_BUF_IN_PTR(ep) (uint8_t xdata *)(in0buf - (( ep & 0x7f) * 128))
           =1 #define CALCULATE_BUF_OUT_PTR(ep) (uint8_t xdata *)(out0buf - (ep * 128 ))
           =1 
           =1 /** An enum describing the USB state
           =1  * 
           =1  *  The states described in this enum are found in Chapter 9 of the USB 2.0 specification
           =1  */
           =1 
           =1 typedef enum  { 
           =1     ATTACHED,   /**< Device is attached to the USB, but is not powered */
           =1     POWERED,    /**< Device is attached to the USB and powered */
           =1     DEFAULT,    /**< Device is attached to the USB and powered and has been reset, but has not been assign
             -ed a unique address */
           =1     ADDRESSED,  /**< Device is attached to the USB, powered, has been reset, and a unique device address h
             -as been assigned. Device is not configured */
           =1     CONFIGURED, /**< Device is attached to the USB, powered, has been reset, has a unique address, is conf
             -igured and is not suspended */
           =1     SUSPENDED   /**< Device is, at a minimum, attached to the USB and is powered and has not seen bus acti
             -vity for 3ms. It may also have a unique address and be configured for use. However, because the device is susended, the 
             -host may not use the device configuration */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 22  

           =1 } hal_usb_state_t;
           =1 
           =1 /** Structure containing the USB standard request
           =1  *  See Chapter 9 USB Device Framework in the USB 2.0 specification.
           =1  */
           =1 
           =1 typedef struct {
           =1     uint8_t  bmRequestType; /**< Bitmapped field identifying the characteristics of the request.
           =1                         - D7: Data transfer direction 
           =1                         - 0 = Host-to-device
           =1                         - 1 = Device-to-host
           =1 
           =1                         - D6..5: Type
           =1                         - 0 = Standard
           =1                         - 1 = Class
           =1                         - 2 = Vendor
           =1                         - 3 = Reserved
           =1 
           =1                         - D4..0: Recipient
           =1                         - 0 = Device
           =1                         - 1 = Interface
           =1                         - 2 = Endpoint
           =1                         - 3 = Other
           =1                         - 4..31 = Reserved
           =1                           */
           =1     uint8_t  bRequest;       /**< Field specifying request. bmRequestType(Type) modify the meaning of this
             - field. */
           =1 
           =1     uint8_t wValueMsb;      /**< Field used to pass a parameter to the device, specific to the request. MS
             -B*/
           =1     uint8_t wValueLsb;      /**< Field used to pass a parameter to the device, specific to the request. LS
             -B*/
           =1     uint8_t wIndex;         /**< Field used to pass a paramters to the device, specific to the request. */
           =1     uint8_t wLength;        /**< Field used to specify length of the data transferred during the second ph
             -ase of the control transfer. Direction of data transfer given by bmRequestType(Direction). If field is zero there is no 
             -data transfer phase. */
           =1 //    void* misc_data;
           =1 } hal_usb_device_req;
           =1 
           =1 /** An enum describing what reply to send to the control request
           =1  */
           =1 
           =1 typedef enum {
           =1     STALL,         /**< Respond with STALL */
           =1     NAK,           /**< Respond with NAK   */
           =1     ACK,           /**< Respond with ACK (if this is an OUT request) */
           =1     NO_RESPONSE,   /**< Do not respond */
           =1     DATA,          /**< Data is available */
           =1     EMPTY_RESPONSE /**< Send an empty response */
           =1 } hal_usb_dev_req_resp_t;
           =1 
           =1 uint8_t ep_1_out_cb(uint8_t xdata *, uint8_t xdata *) reentrant;
           =1 /** Callback function that is called when a class request is received.
           =1  *  The type of class request is determined by the interface the request is for. If interface 1 is a HID i
             -nterface the request is a HID class request.
           =1  *  @param std_req The complete request. 
           =1  *  @param data_ptr Pointer to pointer to data(descriptor struct) the function wants to send back to USB-h
             -ost
           =1  *  @param size Size of data the function wants to send back to USB-host
           =1  */
           =1 
           =1 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 23  

           =1 typedef hal_usb_dev_req_resp_t (*hal_usb_cb_device_req_t)(hal_usb_device_req* device_req, uint8_t ** data_
             -ptr, uint8_t* size) reentrant;
           =1 
           =1 /** Callback function that is called when an endpoint interrupt occur 
           =1  *  @param adr_ptr IN endpoint: Pointer to address containing data to send. OUT endpoint: Pointer to addre
             -ss containg data received.
           =1  *  @param size IN endpoint: Number of bytes to send. OUT endpoint: number of bytes received.
           =1  *  @retval Bit 7 Set: STALL request
           =1  *  @retval Bit 6 Set: NACK request
           =1  *  @retval Bit 5..0 : Bytes to send
           =1  */
           =1 typedef uint8_t (*hal_usb_cb_endpoint_t)(uint8_t xdata *adr_ptr, uint8_t xdata *size) reentrant;
           =1 
           =1 /** Callback function that is called when a resume is signalled on the bus.
           =1  *  A resume is signalled by the Data K state. For full speed devices this is Differential "0". Differenti
             -al "0": D-> Voh(main) and D+ < Vol(max).
           =1  */
           =1 
           =1 typedef void (*hal_usb_cb_resume_t)();
           =1 
           =1 /** Callback function that is called when a suspend condition occur.
           =1  *  @param can_resume Set to 1 if the device is allowed to wake up the host controller
           =1  *  @see hal_usb_state_t
           =1  */
           =1 
           =1 typedef void (*hal_usb_cb_suspend_t)(uint8_t allow_remote_wu) reentrant;
           =1 
           =1 /** Callback function that is called when a reset condition occur.
           =1  *  
           =1  */
           =1 typedef void (*hal_usb_cb_reset_t)();
           =1 
           =1 /** A struct containing variables related to the USB HAL layer 
           =1  *  
           =1  */
           =1 
           =1 typedef struct {
           =1     usb_descs_templ_t descs;     /**< Structure containing device, string and configuration descriptors fo
             -r a specific application */
           =1     uint8_t  bm_state;             /**< Bitmask containing USB state information: bitmask: 0 - is_hw_reset
             -, 1 - can signal remote wakeup, 2 - usb awake */
           =1     uint8_t current_config;        /**< Currently set configuration. If current_config is zero the device 
             -is not configured */
           =1     uint8_t current_alt_interface; /**< Currently alternative configuration. If a alternative configuratio
             -n is chosen the index of the alternative configuration is stored here. */
           =1     hal_usb_state_t state;       /**< Enum containing USB state information as described in Chapter 9 of t
             -he USB 2.0 specification.  */
           =1 
           =1     hal_usb_cb_device_req_t device_req;
           =1     hal_usb_cb_reset_t      reset;
           =1     hal_usb_cb_resume_t     resume;
           =1     hal_usb_cb_suspend_t    suspend;
           =1 } hal_usb_t;
           =1 
           =1 /** Function for setting up the USB controller and registering the callbacks 
           =1  *  @param usb_disconnect Set to true to perform physical disconnect and reconnect. Make sure to enable in
             -terruts as soon as possible after
           =1  *                        the call to this function.
           =1  *  @param device_req Pointer to function to call when a class specific request occur
           =1  *  @param reset Pointer to function to call when USB controller detect a reset
           =1  *  @param resume Pointer to function to call when USB controller detect a resume
           =1  *  @param suspend Pointer to function to call when USB controller detect a suspend
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 24  

           =1  */
           =1 void hal_usb_init(
           =1     bool usb_disconnect,
           =1     hal_usb_cb_device_req_t device_req,
           =1     hal_usb_cb_reset_t      reset,
           =1     hal_usb_cb_resume_t     resume,
           =1     hal_usb_cb_suspend_t    suspend);
           =1 
           =1 /** Function to send a packet to host (IN endpoint)
           =1  *  @param ep_in_num IN endpointer number
           =1  *  @param buffer Pointer to buffer containing data to send
           =1  *  @param bytes_to_send Number of bytes to send.
           =1  */
           =1 void hal_usb_send_data(uint8_t data ep_in_num, uint8_t* data buffer, uint8_t data bytes_to_send);
           =1 
           =1 /** Function to register callbacks for given endpoints 
           =1  *  To register a callback one have to have a function with an argument list equal to usb_endpoint_cb_t.
           =1  *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
           =1  *  @param ep_size The maximum size of one packet for this endpoint
           =1  *  @param endpoint_isr Pointer to function that is called when host issues a request on the given endpoin
             -t. Set to 0 to unregister function.
           =1  */
           =1 void hal_usb_endpoint_config(uint8_t ep_num, uint8_t ep_size, hal_usb_cb_endpoint_t endpoint_isr);
           =1 
           =1 /** Function to stall or unstall an endpoint
           =1  *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
           =1  *  @param stall 1 - stall the endpoint. 0 - unstall the endpoint.
           =1  */
           =1 void hal_usb_endpoint_stall(uint8_t ep_num, bool stall);
           =1 
           =1 /** Function returning the current state of the USB controller
           =1  *  @see usb_stat_t
           =1  */
           =1 hal_usb_state_t hal_usb_get_state();
           =1 
           =1 /** Function returning the assigned address for the device */
           =1 uint8_t hal_usb_get_address();
           =1 
           =1 /** Function to initiate a remote wakeup of the USB host */
           =1 void hal_usb_wakeup();
           =1 
           =1 /** Function to initiate a <b>hardware reset</b> of the USB-controller */
           =1 void hal_usb_reset();
           =1 
           =1 /** Function disconnecting the USB-controller from the USB bus  */
           =1 void hal_usb_bus_disconnect();
           =1 
           =1 /** Function connecting the USB-controller to the USB bus */
           =1 void hal_usb_bus_connect();
           =1 
           =1 /** Function stopping the clock to the usb controller or by other means powers it down */
           =1 void hal_usb_sleep();
           =1 
           =1 extern hal_usb_t g_hal_usb;
           =1 
           =1 #endif //  HAL_USB_H__
 273      =1  /** @} */
   8          #include "hal_usb_desc.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 25  

   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1  * @brief This file contain structures and constants defined in Chapter 9 of the USB 2.0 standard
  16      =1   */
  17      =1  
  18      =1  #ifndef HAL_USB_DESC_H__
           =1 #define HAL_USB_DESC_H__
           =1 
           =1 #include <stdint.h>
           =1 
           =1 // Standard request codes
           =1 #define USB_REQ_GET_STATUS         0x00
           =1 #define USB_REQ_CLEAR_FEATURE      0x01
           =1 #define USB_REQ_RESERVED_1         0x02
           =1 #define USB_REQ_SET_FEATURE        0x03
           =1 #define USB_REQ_RESERVED_2         0x04
           =1 #define USB_REQ_SET_ADDRESS        0x05
           =1 #define USB_REQ_GET_DESCRIPTOR     0x06
           =1 #define USB_REQ_SET_DESCRIPTOR     0x07
           =1 #define USB_REQ_GET_CONFIGURATION  0x08
           =1 #define USB_REQ_SET_CONFIGURATION  0x09
           =1 #define USB_REQ_GET_INTERFACE      0x0a
           =1 #define USB_REQ_SET_INTERFACE      0x0b
           =1 #define USB_REQ_SYNCH_FRAME        0x0c
           =1 
           =1 // Descriptor types
           =1 #define USB_DESC_DEVICE           0x01
           =1 #define USB_DESC_CONFIGURATION    0x02
           =1 #define USB_DESC_STRING           0x03
           =1 #define USB_DESC_INTERFACE        0x04
           =1 #define USB_DESC_ENDPOINT         0x05
           =1 #define USB_DESC_DEVICE_QUAL      0x06
           =1 #define USB_DESC_OTHER_SPEED_CONF 0x07
           =1 #define USB_DESC_INTERFACE_POWER  0x08
           =1 #define USB_DESC_OTG              0x09
           =1 #define USB_DESC_DEBUG            0x0A
           =1 #define USB_DESC_INTERFACE_ASSOC  0x0B
           =1 
           =1 #define USB_ENDPOINT_TYPE_CONTROL           0x00
           =1 #define USB_ENDPOINT_TYPE_ISOCHRONOUS       0x01
           =1 #define USB_ENDPOINT_TYPE_BULK              0x02
           =1 #define USB_ENDPOINT_TYPE_INTERRUPT         0x03
           =1 
           =1 // USB device classes
           =1 #define USB_DEVICE_CLASS_RESERVED               0x00
           =1 #define USB_DEVICE_CLASS_AUDIO                  0x01
           =1 #define USB_DEVICE_CLASS_COMMUNICATIONS         0x02
           =1 #define USB_DEVICE_CLASS_HUMAN_INTERFACE        0x03
           =1 #define USB_DEVICE_CLASS_MONITOR                0x04
           =1 #define USB_DEVICE_CLASS_PHYSICAL_INTERFACE     0x05
           =1 #define USB_DEVICE_CLASS_POWER                  0x06
           =1 #define USB_DEVICE_CLASS_PRINTER                0x07
           =1 #define USB_DEVICE_CLASS_STORAGE                0x08
           =1 #define USB_DEVICE_CLASS_HUB                    0x09
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 26  

           =1 #define USB_DEVICE_CLASS_APPLICATION_SPECIFIC   0xFE
           =1 #define USB_DEVICE_CLASS_VENDOR_SPECIFIC        0xFF
           =1 
           =1 
           =1 #define USB_CLASS_DESCRIPTOR_HID    0x21
           =1 #define USB_CLASS_DESCRIPTOR_REPORT 0x22
           =1 #define USB_CLASS_DESCRIPTOR_PHYSICAL_DESCRIPTOR 0x23
           =1 
           =1 #define USB_DEVICE_REMOTE_WAKEUP    0x01
           =1 #define USB_ENDPOINT_HALT           0x00
           =1 #define USB_TEST_MODE               0x02
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint16_t bcdUSB;
           =1      volatile uint8_t bDeviceClass;
           =1      volatile uint8_t bDeviceSubClass;
           =1      volatile uint8_t bDeviceProtocol;
           =1      volatile uint8_t bMaxPacketSize0;
           =1      volatile uint16_t idVendor;
           =1      volatile uint16_t idProduct;
           =1      volatile uint16_t bcdDevice;
           =1      volatile uint8_t iManufacturer;
           =1      volatile uint8_t iProduct;
           =1      volatile uint8_t iSerialNumber;
           =1      volatile uint8_t bNumConfigurations;
           =1 } hal_usb_dev_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint16_t wTotalLength;
           =1      volatile uint8_t bNumInterfaces;
           =1      volatile uint8_t bConfigurationValue;
           =1      volatile uint8_t iConfiguration;
           =1      volatile uint8_t bmAttributes;
           =1      volatile uint8_t bMaxPower;
           =1 } hal_usb_conf_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint8_t bInterfaceNumber;
           =1      volatile uint8_t bAlternateSetting;
           =1      volatile uint8_t bNumEndpoints;
           =1      volatile uint8_t bInterfaceClass;
           =1      volatile uint8_t bInterfaceSubClass;
           =1      volatile uint8_t bInterfaceProtocol;
           =1      volatile uint8_t iInterface;
           =1 } hal_usb_if_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint8_t bEndpointAddress;
           =1      volatile uint8_t bmAttributes;
           =1      volatile uint16_t wMaxPacketSize;
           =1      volatile uint8_t bInterval;
           =1 } hal_usb_ep_desc_t;
           =1 
           =1 /*
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 27  

           =1 typedef struct {
           =1     volatile uint8_t bLength;
           =1     volatile uint8_t bDescriptorType;
           =1     volatile uint16_t bcdHID;
           =1     volatile uint8_t bCountryCode;
           =1     volatile uint8_t bNumDescriptors;
           =1     volatile uint8_t bDescriptorType2;
           =1     volatile uint16_t wDescriptorLength;
           =1 } hal_usb_hid_desc_t;
           =1 
           =1 
           =1 typedef struct {
           =1      volatile uint8_t* desc;
           =1 } hal_usb_string_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1 } hal_usb_common_desc_t;
           =1   */
           =1 
           =1 #endif // HAL_USB_DESC_H__
   9          #include "usb_cmds.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5718 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Definition of supported USB commands
  16      =1   *
  17      =1   */
  18      =1  #ifndef USB_CMDS_H__
  19      =1  #define USB_CMDS_H__
  20      =1  
  21      =1  typedef enum
  22      =1  {
  23      =1    CMD_FIRMWARE_VERSION = 1,
  24      =1    CMD_FLASH_WRITE_INIT,         // Eigth 64 bytes bulk packets <- PC follow after this command
  25      =1    CMD_FLASH_READ,
  26      =1    CMD_FLASH_ERASE_PAGE,
  27      =1    CMD_FLASH_SET_PROTECTED,
  28      =1    CMD_FLASH_SELECT_HALF
  29      =1  } usb_command_t;
  30      =1  
  31      =1  #endif // USB_CMDS_H__
  10          #include "config.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 28  

   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5718 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Configuration file for bootloader
  16      =1   *
  17      =1   */
  18      =1  #ifndef CONFIG_H__
           =1 #define CONFIG_H__
           =1 
           =1 #define FLASH_PAGE_SIZE     512U
           =1 #define MAX_PACKET_SIZE_EP0 32
           =1 #define USB_EP1_SIZE        64
           =1 #define FLASH_SIZE          (32U*1024U)
           =1 #define NUM_FLASH_PAGES     FLASH_SIZE/FLASH_PAGE_SIZE
           =1 
           =1 #endif // CONFIG_H__
  11            
  12          #include "cklf.h"   
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface functions for the low frequency clock module.
  16      =1   * @defgroup hal_nrf24lu1p_cklf Low frequency clock (cklf)
  17      =1   * @{
  18      =1   * @ingroup hal_nrf24lu1p
  19      =1   * in the nRF24LU1
  20      =1   */
  21      =1  #ifndef CKLF_H__
  22      =1  #define CKLF_H__
  23      =1  
  24      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 29  

  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  25      =1  
  26      =1  /** Function to write to the low frequency clock interface (CKLF) in nRF24LU1.
  27      =1   * @param addr the address of the register to write
  28      =1   * @param val the value to write to the register
  29      =1   */
  30      =1  void cklf_regxc_write(uint8_t addr, uint16_t val);
  31      =1  
  32      =1  /** Function to read the low frequency clock interface (CKLF) in nRF24LU1.
  33      =1   * @param addr the address of the register to read
  34      =1   * @return the value read
  35      =1   */
  36      =1  uint16_t cklf_regxc_read(uint8_t addr);
  37      =1  
  38      =1  /** Function to disable the RTC.
  39      =1   * This function should be called before reading values from the RTC counter.
  40      =1   */
  41      =1  void cklf_rtc_disable(void);
  42      =1  
  43      =1  /** Function to initialize the RTC.
  44      =1   *  @param cnt_h The upper 8 bits of the 24 bit value to load into the RTC latch
  45      =1   *  @param cnt_l The lower 16 bits of the 24 bit value to load into the RTC latch
  46      =1   */
  47      =1  void cklf_rtc_init(uint8_t cnt_h, uint16_t cnt_l);
  48      =1  
  49      =1  /** Function to read the lower 16 bits of the RTC counter.
  50      =1   *  To ensure consistency between the return value of this function and
  51      =1   *  cklf_rtc_read_msb the RTC should be disabled before calling these functions.
  52      =1   *  @return The lower 16 bits of the RTC counter.
  53      =1   */
  54      =1  uint16_t cklf_rtc_read_lsw(void);
  55      =1  
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 30  

  56      =1  /** Function to read the upper 8 bits of the RTC counter.
  57      =1   *  To ensure consistency between the return value of this function and
  58      =1   *  cklf_rtc_read_lsw the RTC should be disabled before calling these functions.
  59      =1   *  @return The upper 8 bits of the RTC counter.
  60      =1   */
  61      =1  uint8_t cklf_rtc_read_msb(void);
  62      =1  
  63      =1  /** Function to wait for the RTC counter to reach 0.
  64      =1   * This function enters an infinite loop polling the RTC interrupt flag. When
  65      =1   * the flag is set the flag is cleared and the function returns.
  66      =1   *
  67      =1   */
  68      =1  void cklf_rtc_wait(void);
  69      =1  
  70      =1  /** Function to initialize and enable the watch dog.
  71      =1   * @param cnt The value to load into the watch dog counter.
  72      =1   */
  73      =1  void cklf_wdog_init(uint16_t cnt);
  74      =1  
  75      =1  /** Function to reload the watch dog.
  76      =1   * This function reloads the watch dog counter with the parameter given in the
  77      =1   * hal_wdog_init function.
  78      =1   */
  79      =1  void cklf_wdog_feed(void);
  80      =1  
  81      =1  /** Function to program the GPIO wakeup functionality
  82      =1   *  @param wcon0 Value of WCON0 register (P00 - P03) 
  83      =1   *  @param wcon1 Value of WCON1 register (P04 - P07)
  84      =1   */
  85      =1  void cklf_gpio_wakeup(uint16_t wcon1, uint16_t wcon0);
  86      =1  
  87      =1  #endif // CKLF_H__
  88      =1  /** @} */
  13          #include "cpu.h"   
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief CPU management functions.
  16      =1   * @defgroup hal_nrf24lu1p_cpu CPU management (cpu) 
  17      =1   * @{
  18      =1   * @ingroup hal_nrf24lu1p
  19      =1   */
  20      =1  #ifndef CPU_H__
  21      =1  #define CPU_H__
  22      =1  
  23      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 31  

   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  24      =1  
  25      =1  /** Function to set the CPU in power down mode
  26      =1   *  @return This function does not retun until the CPU wakens
  27      =1   */
  28      =1  void cpu_pwr_down(void);
  29      =1  
  30      =1  /** Function to set the clock frequency of the chip
  31      =1   *  cf is the value of the CLKCTL register but only bits 4-6 are used in this
  32      =1   *  function.
  33      =1   *  @param cf The clock frequency 
  34      =1   */
  35      =1  void cpu_set_clock_frequency(uint8_t cf);
  36      =1  
  37      =1  #endif // CPU_H__
  38      =1  /** @} */
  14          
  15          #include "nordic_common.h"  
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 32  

   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5756 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
  16      =1   *
  17      =1   */
  18      =1  
  19      =1  #ifndef NORDIC_COMMON_H__
  20      =1  #define NORDIC_COMMON_H__
  21      =1  
  22      =1  /** Swaps the upper byte with the lower byte in a 16 bit variable */
  23      =1  //lint -emacro((572),SWAP) // Suppress warning 572 "Excessive shift value"
  24      =1  #define SWAP(x) ((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
  25      =1  
  26      =1  /** The upper 8 bits of a 16 bit value */
  27      =1  #define MSB(a) ((a & 0xFF00) >> 8)
  28      =1  /** The lower 8 bits (of a 16 bit value) */
  29      =1  #define LSB(a) ((a & 0xFF))
  30      =1  
  31      =1  /** Leaves the minimum of the two arguments */
  32      =1  #define MIN(a, b) ((a) < (b) ? (a) : (b))
  33      =1  /** Leaves the maximum of the two arguments */
  34      =1  #define MAX(a, b) ((a) < (b) ? (b) : (a))
  35      =1  
  36      =1  #define BIT_0 0x01 /**< The value of bit 0 */
  37      =1  #define BIT_1 0x02 /**< The value of bit 1 */
  38      =1  #define BIT_2 0x04 /**< The value of bit 2 */
  39      =1  #define BIT_3 0x08 /**< The value of bit 3 */
  40      =1  #define BIT_4 0x10 /**< The value of bit 4 */
  41      =1  #define BIT_5 0x20 /**< The value of bit 5 */
  42      =1  #define BIT_6 0x40 /**< The value of bit 6 */
  43      =1  #define BIT_7 0x80 /**< The value of bit 7 */
  44      =1  #define BIT_8 0x0100 /**< The value of bit 8 */
  45      =1  #define BIT_9 0x0200 /**< The value of bit 9 */
  46      =1  #define BIT_10 0x0400 /**< The value of bit 10 */
  47      =1  #define BIT_11 0x0800 /**< The value of bit 11 */
  48      =1  #define BIT_12 0x1000 /**< The value of bit 12 */
  49      =1  #define BIT_13 0x2000 /**< The value of bit 13 */
  50      =1  #define BIT_14 0x4000 /**< The value of bit 14 */
  51      =1  #define BIT_15 0x8000 /**< The value of bit 15 */
  52      =1  
  53      =1  
  54      =1  #endif // NORDIC_COMMON_H__
  16          
  17          #include "hal_nrf.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 33  

  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface functions for the on-chip radio transceiver. 
  16      =1   */
  17      =1   
  18      =1  /** @defgroup hal_nrf24l01p_hal_nrf RF tranceiver (hal_nrf)
  19      =1   * @{
  20      =1   * @ingroup hal_nrf24l01p
  21      =1   * 
  22      =1   * This is the nRF24L01+ transceiver used in several Nordic Semiconductor devices.
  23      =1   * The transceiver is set up and controlled via an internal SPI interface on the chip. 
  24      =1   * The HAL for the radio transceiver hides this SPI interface from the programmer.
  25      =1   *
  26      =1   * The nRF24LE1 uses the same 2.4GHz GFSK RF transceiver with embedded protocol engine 
  27      =1   * (Enhanced ShockBurst&tm;) that is found in the nRF24L01+ single chip RF Transceiver.
  28      =1   *
  29      =1   * The RF Transceiver module is configured and operated through the RF transceiver map. 
  30      =1   * This register map is accessed by the MCU through a dedicated on-chip Serial 
  31      =1   * Peripheral interface (SPI) and is available in all power modes of the RF Transceiver 
  32      =1   * module. The register map contains all configuration registers in the RF Transceiver 
  33      =1   * and is accessible in all operation modes of the transceiver. The radio transceiver 
  34      =1   * HAL hides this register map and the usage of the internal SPI.
  35      =1   * 
  36      =1   * This HAL module contains setup functions for configurating the radio; operation functions 
  37      =1   * for controlling the radio when active and for sending and receiving data; and test 
  38      =1   * functions for setting the radio in test modes.
  39      =1   */
  40      =1  
  41      =1  #ifndef HAL_NRF_H__
  42      =1  #define HAL_NRF_H__
  43      =1  
  44      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 34  

           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  45      =1  #include <stdbool.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDBOOL_H__
           =2 #define __STDBOOL_H__
           =2 
           =2 //lint -strong(B,_Bool)
           =2 typedef unsigned char _Bool; ///< Boolean type
           =2 
           =2 #define bool _Bool
           =2 #define true 1
           =2 #define false 0
           =2 #define __bool_true_false_are_defined 1
           =2 
           =2 #endif // __STDBOOL_H__
  46      =1  
  47      =1  #include "hal_nrf_reg.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 35  

   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 5717 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  @brief Register definitions for nRF24L01+
  16      =2  
  17      =2  @details Header file defining register mapping with bit definitions. 
  18      =2  This file is radio-chip dependent, and are included with the hal_nrf.h
  19      =2  
  20      =2  @ingroup hal_nrf24l01p_hal_nrf
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_REG_H__
  24      =2  #define HAL_NRF_REG_H__
  25      =2  
  26      =2  /** @name - Instruction Set - */
  27      =2  //@{
  28      =2  /* nRF24L01 Instruction Definitions */
  29      =2  #define W_REGISTER         0x20  /**< Register write command */
  30      =2  #define R_RX_PAYLOAD       0x61  /**< Read RX payload command */
  31      =2  #define W_TX_PAYLOAD       0xA0  /**< Write TX payload command */
  32      =2  #define FLUSH_TX           0xE1  /**< Flush TX register command */
  33      =2  #define FLUSH_RX           0xE2  /**< Flush RX register command */
  34      =2  #define REUSE_TX_PL        0xE3  /**< Reuse TX payload command */
  35      =2  #define ACTIVATE           0x50  /**< Activate features */
  36      =2  #define R_RX_PL_WID        0x60  /**< Read RX payload command */
  37      =2  #define W_ACK_PAYLOAD      0xA8  /**< Write ACK payload command */
  38      =2  #define W_TX_PAYLOAD_NOACK 0xB0  /**< Write ACK payload command */
  39      =2  #define NOP                0xFF  /**< No Operation command, used for reading status register */
  40      =2  //@}
  41      =2  
  42      =2  /** @name  - Register Memory Map - */
  43      =2  //@{
  44      =2  /* nRF24L01 * Register Definitions * */
  45      =2  #define CONFIG        0x00  /**< nRF24L01 config register */
  46      =2  #define EN_AA         0x01  /**< nRF24L01 enable Auto-Acknowledge register */
  47      =2  #define EN_RXADDR     0x02  /**< nRF24L01 enable RX addresses register */
  48      =2  #define SETUP_AW      0x03  /**< nRF24L01 setup of address width register */
  49      =2  #define SETUP_RETR    0x04  /**< nRF24L01 setup of automatic retransmission register */
  50      =2  #define RF_CH         0x05  /**< nRF24L01 RF channel register */
  51      =2  #define RF_SETUP      0x06  /**< nRF24L01 RF setup register */
  52      =2  #define STATUS        0x07  /**< nRF24L01 status register */
  53      =2  #define OBSERVE_TX    0x08  /**< nRF24L01 transmit observe register */
  54      =2  #define CD            0x09  /**< nRF24L01 carrier detect register */
  55      =2  #define RX_ADDR_P0    0x0A  /**< nRF24L01 receive address data pipe0 */
  56      =2  #define RX_ADDR_P1    0x0B  /**< nRF24L01 receive address data pipe1 */
  57      =2  #define RX_ADDR_P2    0x0C  /**< nRF24L01 receive address data pipe2 */
  58      =2  #define RX_ADDR_P3    0x0D  /**< nRF24L01 receive address data pipe3 */
  59      =2  #define RX_ADDR_P4    0x0E  /**< nRF24L01 receive address data pipe4 */
  60      =2  #define RX_ADDR_P5    0x0F  /**< nRF24L01 receive address data pipe5 */
  61      =2  #define TX_ADDR       0x10  /**< nRF24L01 transmit address */
  62      =2  #define RX_PW_P0      0x11  /**< nRF24L01 \# of bytes in rx payload for pipe0 */
  63      =2  #define RX_PW_P1      0x12  /**< nRF24L01 \# of bytes in rx payload for pipe1 */
  64      =2  #define RX_PW_P2      0x13  /**< nRF24L01 \# of bytes in rx payload for pipe2 */
  65      =2  #define RX_PW_P3      0x14  /**< nRF24L01 \# of bytes in rx payload for pipe3 */
  66      =2  #define RX_PW_P4      0x15  /**< nRF24L01 \# of bytes in rx payload for pipe4 */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 36  

  67      =2  #define RX_PW_P5      0x16  /**< nRF24L01 \# of bytes in rx payload for pipe5 */
  68      =2  #define FIFO_STATUS   0x17  /**< nRF24L01 FIFO status register */
  69      =2  #define DYNPD         0x1C  /**< nRF24L01 Dynamic payload setup */
  70      =2  #define FEATURE       0x1D  /**< nRF24L01 Exclusive feature setup */
  71      =2  #define AGC_CONFIG    0x1E  /**< nRF24L01+ AGC configuration register */
  72      =2  
  73      =2  //@}
  74      =2  
  75      =2  /* nRF24L01 related definitions */
  76      =2  /* Interrupt definitions */
  77      =2  /* Operation mode definitions */
  78      =2  
  79      =2  /** An enum describing the radio's irq sources.
  80      =2   *
  81      =2   */
  82      =2  typedef enum {
  83      =2      HAL_NRF_MAX_RT = 4,     /**< Max retries interrupt */
  84      =2      HAL_NRF_TX_DS,          /**< TX data sent interrupt */
  85      =2      HAL_NRF_RX_DR           /**< RX data received interrupt */
  86      =2  } hal_nrf_irq_source_t;
  87      =2  
  88      =2  /* Operation mode definitions */
  89      =2  /** An enum describing the radio's power mode.
  90      =2   *
  91      =2   */
  92      =2  typedef enum {
  93      =2      HAL_NRF_PTX,            /**< Primary TX operation */
  94      =2      HAL_NRF_PRX             /**< Primary RX operation */
  95      =2  } hal_nrf_operation_mode_t;
  96      =2  
  97      =2  /** An enum describing the radio's power mode.
  98      =2   *
  99      =2   */
 100      =2  typedef enum {
 101      =2      HAL_NRF_PWR_DOWN,       /**< Device power-down */
 102      =2      HAL_NRF_PWR_UP          /**< Device power-up */
 103      =2  } hal_nrf_pwr_mode_t;
 104      =2  
 105      =2  /** An enum describing the radio's output power mode's.
 106      =2   *
 107      =2   */
 108      =2  typedef enum {
 109      =2      HAL_NRF_18DBM,          /**< Output power set to -18dBm */
 110      =2      HAL_NRF_12DBM,          /**< Output power set to -12dBm */
 111      =2      HAL_NRF_6DBM,           /**< Output power set to -6dBm  */
 112      =2      HAL_NRF_0DBM            /**< Output power set to 0dBm   */
 113      =2  } hal_nrf_output_power_t;
 114      =2  
 115      =2  /** An enum describing the radio's on-air datarate.
 116      =2   *
 117      =2   */
 118      =2  typedef enum {
 119      =2      HAL_NRF_1MBPS,          /**< Datarate set to 1 Mbps  */
 120      =2      HAL_NRF_2MBPS,          /**< Datarate set to 2 Mbps  */
 121      =2      HAL_NRF_250KBPS         /**< Datarate set to 250 kbps*/
 122      =2  } hal_nrf_datarate_t;
 123      =2  
 124      =2  /** An enum describing the radio's CRC mode.
 125      =2   *
 126      =2   */
 127      =2  typedef enum {
 128      =2      HAL_NRF_CRC_OFF,    /**< CRC check disabled */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 37  

 129      =2      HAL_NRF_CRC_8BIT,   /**< CRC check set to 8-bit */
 130      =2      HAL_NRF_CRC_16BIT   /**< CRC check set to 16-bit */
 131      =2  } hal_nrf_crc_mode_t;
 132      =2  
 133      =2  /** An enum describing the read/write payload command.
 134      =2   *
 135      =2   */
 136      =2  typedef enum {
 137      =2      HAL_NRF_TX_PLOAD = 7,   /**< TX payload definition */
 138      =2      HAL_NRF_RX_PLOAD,        /**< RX payload definition */
 139      =2      HAL_NRF_ACK_PLOAD
 140      =2  } hal_nrf_pload_command_t;
 141      =2  
 142      =2  /** Structure containing the radio's address map.
 143      =2   * Pipe0 contains 5 unique address bytes,
 144      =2   * while pipe[1..5] share the 4 MSB bytes, set in pipe1.
 145      =2   * <p><b> - Remember that the LSB byte for all pipes have to be unique! -</b>
 146      =2   */
 147      =2  // nRF24L01 Address struct
 148      =2  
 149      =2  
 150      =2  //typedef struct {
 151      =2  //   uint8_t p0[5];            /**< Pipe0 address, 5 bytes */
 152      =2  //    uint8_t p1[5];            /**< Pipe1 address, 5 bytes, 4 MSB bytes shared for pipe1 to pipe5 */
 153      =2  //    uint8_t p2[1];            /**< Pipe2 address, 1 byte */
 154      =2  //    uint8_t p3[1];            /**< Pipe3 address, 1 byte */
 155      =2  //   uint8_t p4[1];            /**< Pipe3 address, 1 byte */
 156      =2  //   uint8_t p5[1];            /**< Pipe3 address, 1 byte */
 157      =2  //   uint8_t tx[5];            /**< TX address, 5 byte */
 158      =2  //} hal_nrf_l01_addr_map;
 159      =2  
 160      =2  
 161      =2  /** An enum describing the nRF24L01 pipe addresses and TX address.
 162      =2   *
 163      =2   */
 164      =2  typedef enum {
 165      =2      HAL_NRF_PIPE0,              /**< Select pipe0 */
 166      =2      HAL_NRF_PIPE1,              /**< Select pipe1 */
 167      =2      HAL_NRF_PIPE2,              /**< Select pipe2 */
 168      =2      HAL_NRF_PIPE3,              /**< Select pipe3 */
 169      =2      HAL_NRF_PIPE4,              /**< Select pipe4 */
 170      =2      HAL_NRF_PIPE5,              /**< Select pipe5 */
 171      =2      HAL_NRF_TX,                 /**< Refer to TX address*/
 172      =2      HAL_NRF_ALL = 0xFF          /**< Close or open all pipes*/
 173      =2                                  /**< @see hal_nrf_set_address @see hal_nrf_get_address
 174      =2                                   @see hal_nrf_open_pipe  @see hal_nrf_close_pipe */
 175      =2  } hal_nrf_address_t;
 176      =2  
 177      =2  /** An enum describing the radio's address width.
 178      =2   *
 179      =2   */
 180      =2  typedef enum {
 181      =2      HAL_NRF_AW_3BYTES = 3,      /**< Set address width to 3 bytes */
 182      =2      HAL_NRF_AW_4BYTES,          /**< Set address width to 4 bytes */
 183      =2      HAL_NRF_AW_5BYTES           /**< Set address width to 5 bytes */
 184      =2  } hal_nrf_address_width_t;
 185      =2  
 186      =2  
 187      =2  /** @name CONFIG register bit definitions */
 188      =2  //@{
 189      =2  
 190      =2  #define MASK_RX_DR    6     /**< CONFIG register bit 6 */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 38  

 191      =2  #define MASK_TX_DS    5     /**< CONFIG register bit 5 */
 192      =2  #define MASK_MAX_RT   4     /**< CONFIG register bit 4 */
 193      =2  #define EN_CRC        3     /**< CONFIG register bit 3 */
 194      =2  #define CRCO          2     /**< CONFIG register bit 2 */
 195      =2  #define PWR_UP        1     /**< CONFIG register bit 1 */
 196      =2  #define PRIM_RX       0     /**< CONFIG register bit 0 */
 197      =2  //@}
 198      =2  
 199      =2  /** @name RF_SETUP register bit definitions */
 200      =2  //@{
 201      =2  #define PLL_LOCK      4     /**< RF_SETUP register bit 4 */
 202      =2  #define RF_DR         3     /**< RF_SETUP register bit 3 */
 203      =2  #define RF_PWR1       2     /**< RF_SETUP register bit 2 */
 204      =2  #define RF_PWR0       1     /**< RF_SETUP register bit 1 */
 205      =2  #define LNA_HCURR     0     /**< RF_SETUP register bit 0 */
 206      =2  //@}
 207      =2  
 208      =2  /* STATUS 0x07 */
 209      =2  /** @name STATUS register bit definitions */
 210      =2  //@{
 211      =2  #define RX_DR         6     /**< STATUS register bit 6 */
 212      =2  #define TX_DS         5     /**< STATUS register bit 5 */
 213      =2  #define MAX_RT        4     /**< STATUS register bit 4 */
 214      =2  #define TX_FULL       0     /**< STATUS register bit 0 */
 215      =2  //@}
 216      =2  
 217      =2  /* FIFO_STATUS 0x17 */
 218      =2  /** @name FIFO_STATUS register bit definitions */
 219      =2  //@{
 220      =2  #define TX_REUSE      6     /**< FIFO_STATUS register bit 6 */
 221      =2  #define TX_FIFO_FULL  5     /**< FIFO_STATUS register bit 5 */
 222      =2  #define TX_EMPTY      4     /**< FIFO_STATUS register bit 4 */
 223      =2  #define RX_FULL       1     /**< FIFO_STATUS register bit 1 */
 224      =2  #define RX_EMPTY      0     /**< FIFO_STATUS register bit 0 */
 225      =2  //@}
 226      =2  
 227      =2  #endif // HAL_NRF_REG_H__
 228      =2  /** @} */
  48      =1  #include "hal_nrf_hw.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 5717 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  * @brief hal_nrf macros for nRF24LU1+
  16      =2   *
  17      =2   * @defgroup hal_nrf24lu1p_hal_nrf_hw hal_nrf_hw
  18      =2   * @{
  19      =2   * @ingroup hal_nrf24lu1p
  20      =2   *
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_LU1_H__
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 39  

  24      =2  #define HAL_NRF_LU1_H__
  25      =2  
  26      =2  #include <Nordic\reg24lu1.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3   * reg24lu1.h
   3      =3   *
   4      =3   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =3   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =3   *
   7      =3   *
   8      =3   *------------------------------------------------------------------------*/
   9      =3  #ifndef __REG24LU1_H__
           =3 #define __REG24LU1_H__
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Byte Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 sfr   P0           = 0x80;
           =3 sfr   SP           = 0x81;
           =3 sfr   DPL          = 0x82;
           =3 sfr   DPH          = 0x83;
           =3 sfr   DPL1         = 0x84;
           =3 sfr   DPH1         = 0x85;
           =3 sfr   PCON         = 0x87;
           =3 sfr   TCON         = 0x88;
           =3 sfr   TMOD         = 0x89;
           =3 sfr   TL0          = 0x8A;
           =3 sfr   TL1          = 0x8B;
           =3 sfr   TH0          = 0x8C;
           =3 sfr   TH1          = 0x8D;
           =3 sfr   CKCON        = 0x8E;
           =3 sfr   RFCON        = 0x90;
           =3 sfr   DPS          = 0x92;
           =3 sfr   P0DIR        = 0x94;
           =3 sfr   P0ALT        = 0x95;
           =3 sfr   S0CON        = 0x98;
           =3 sfr   S0BUF        = 0x99;
           =3 sfr   IEN2         = 0x9A;
           =3 sfr   USBCON       = 0xA0;
           =3 sfr   CLKCTL       = 0xA3;
           =3 sfr   PWRDWN       = 0xA4;
           =3 sfr   WUCONF       = 0xA5;
           =3 sfr   INTEXP       = 0xA6;
           =3 sfr   IEN0         = 0xA8;
           =3 sfr   IP0          = 0xA9;
           =3 sfr   S0RELL       = 0xAA;
           =3 sfr   REGXH        = 0xAB;
           =3 sfr   REGXL        = 0xAC;
           =3 sfr   REGXC        = 0xAD;
           =3 sfr   RSTRES       = 0xB1;
           =3 sfr   SMDAT        = 0xB2;
           =3 sfr   SMCTL        = 0xB3;
           =3 sfr   TICKDV       = 0xB5;
           =3 sfr   IEN1         = 0xB8;
           =3 sfr   IP1          = 0xB9;
           =3 sfr   S0RELH       = 0xBA;
           =3 sfr   SSCONF       = 0xBC;
           =3 sfr   SSDATA       = 0xBD;
           =3 sfr   SSSTAT       = 0xBE;
           =3 sfr   IRCON        = 0xC0;
           =3 sfr   CCEN         = 0xC1;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 40  

           =3 sfr   CCL1         = 0xC2;
           =3 sfr   CCH1         = 0xC3;
           =3 sfr   CCL2         = 0xC4;
           =3 sfr   CCH2         = 0xC5;
           =3 sfr   CCL3         = 0xC6;
           =3 sfr   CCH3         = 0xC7;
           =3 sfr   T2CON        = 0xC8;
           =3 sfr   P0EXP        = 0xC9;
           =3 sfr   CRCL         = 0xCA;
           =3 sfr   CRCH         = 0xCB;
           =3 sfr   TL2          = 0xCC;
           =3 sfr   TH2          = 0xCD;
           =3 sfr   PSW          = 0xD0;
           =3 sfr   WDCON        = 0xD8;
           =3 sfr   USBSLP       = 0xD9;
           =3 sfr   ACC          = 0xE0;
           =3 sfr   RFDAT        = 0xE5;
           =3 sfr   RFCTL        = 0xE6;
           =3 sfr   AESCS        = 0xE8;
           =3 sfr   MD0          = 0xE9;
           =3 sfr   MD1          = 0xEA;
           =3 sfr   MD2          = 0xEB;
           =3 sfr   MD3          = 0xEC;
           =3 sfr   MD4          = 0xED;
           =3 sfr   MD5          = 0xEE;
           =3 sfr   ARCON        = 0xEF;
           =3 sfr   B            = 0xF0;
           =3 sfr   AESKIN       = 0xF1;
           =3 sfr   AESIV        = 0xF2;
           =3 sfr   AESD         = 0xF3;
           =3 sfr   AESIA1       = 0xF5;
           =3 sfr   AESIA2       = 0xF6;
           =3 sfr   FSR          = 0xF8;
           =3 sfr   FPCR         = 0xF9;
           =3 sfr   FCR          = 0xFA;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Word Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 sfr16 CC1          = 0xC2;
           =3 sfr16 CC2          = 0xC4;
           =3 sfr16 CC3          = 0xC6;
           =3 sfr16 CRC          = 0xCA;
           =3 sfr16 T2           = 0xCC;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
           =3    This causes errors due to the strong type checking of _Bool (and thereby bool) that
           =3    is turned on in our implementation of stdbool.h.
           =3    Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
           =3 */
           =3 
           =3 /*lint -e18 */
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 /*  FSR  */
           =3 sbit  MCDIS        = FSR^7;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 41  

           =3 sbit  STP          = FSR^6;
           =3 sbit  WEN          = FSR^5;
           =3 sbit  RDYN         = FSR^4;
           =3 sbit  INFEN        = FSR^3;
           =3 sbit  RDIS         = FSR^2;
           =3 sbit  RDEND        = FSR^1;
           =3 sbit  WPEN         = FSR^0;
           =3 
           =3 /*  PSW   */
           =3 sbit  CY           = PSW^7;
           =3 sbit  AC           = PSW^6;
           =3 sbit  F0           = PSW^5;
           =3 sbit  RS1          = PSW^4;
           =3 sbit  RS0          = PSW^3;
           =3 sbit  OV           = PSW^2;
           =3 sbit  F1           = PSW^1;
           =3 sbit  P            = PSW^0;
           =3 
           =3 /*  TCON  */
           =3 sbit  TF1          = TCON^7;
           =3 sbit  TR1          = TCON^6;
           =3 sbit  TF0          = TCON^5;
           =3 sbit  TR0          = TCON^4;
           =3 sbit  IE1          = TCON^3;
           =3 sbit  IT1          = TCON^2;
           =3 sbit  IE0          = TCON^1;
           =3 sbit  IT0          = TCON^0;
           =3 
           =3 /*  S0CON  */
           =3 sbit  SM0          = S0CON^7;
           =3 sbit  SM1          = S0CON^6;
           =3 sbit  SM20         = S0CON^5;
           =3 sbit  REN0         = S0CON^4;
           =3 sbit  TB80         = S0CON^3;
           =3 sbit  RB80         = S0CON^2;
           =3 sbit  TI0          = S0CON^1;
           =3 sbit  RI0          = S0CON^0;
           =3 
           =3 /*  T2CON  */
           =3 sbit  T2PS         = T2CON^7;
           =3 sbit  I3FR         = T2CON^6;
           =3 sbit  I2FR         = T2CON^5;
           =3 sbit  T2R1         = T2CON^4;
           =3 sbit  T2R0         = T2CON^3;
           =3 sbit  T2CM         = T2CON^2;
           =3 sbit  T2I1         = T2CON^1;
           =3 sbit  T2I0         = T2CON^0;
           =3 
           =3 /*  IEN0  */
           =3 sbit  EA           = IEN0^7;
           =3 
           =3 sbit  ET2          = IEN0^5;
           =3 sbit  ES0          = IEN0^4;
           =3 sbit  ET1          = IEN0^3;
           =3 sbit  EX1          = IEN0^2;
           =3 sbit  ET0          = IEN0^1;
           =3 sbit  EX0          = IEN0^0;
           =3 
           =3 /* IEN1  */
           =3 sbit  EXEN2        = IEN1^7;
           =3 
           =3 sbit  WUIRQ        = IEN1^5;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 42  

           =3 sbit  USB          = IEN1^4;
           =3 sbit  USBWU        = IEN1^3;
           =3 sbit  SPI          = IEN1^2;
           =3 sbit  RF           = IEN1^1;
           =3 sbit  RFSPI        = IEN1^0;
           =3 
           =3 /* IRCON */
           =3 sbit  EXF2         = IRCON^7;
           =3 sbit  TF2          = IRCON^6;
           =3 sbit  WUF          = IRCON^5;
           =3 sbit  USBF         = IRCON^4;
           =3 sbit  USBWUF       = IRCON^3;
           =3 sbit  SPIF         = IRCON^2;
           =3 sbit  RFF          = IRCON^1;
           =3 sbit  RFSPIF       = IRCON^0;
           =3 
           =3 /* USBCON */
           =3 sbit  SWRST        = USBCON^7;
           =3 sbit  WU           = USBCON^6;
           =3 sbit  SUSPEND      = USBCON^5;
           =3 sbit  IV4          = USBCON^4;
           =3 sbit  IV3          = USBCON^3;
           =3 sbit  IV2          = USBCON^2;
           =3 sbit  IV1          = USBCON^1;
           =3 sbit  IV0          = USBCON^0;
           =3 
           =3 /* PORT0 */
           =3 sbit  P00          = P0^0;
           =3 sbit  P01          = P0^1;
           =3 sbit  P02          = P0^2;
           =3 sbit  P03          = P0^3;
           =3 sbit  MCSN         = P0^3;
           =3 sbit  SCSN         = P0^3;
           =3 sbit  P04          = P0^4;
           =3 sbit  P05          = P0^5;
           =3 
           =3 /* RFCON */
           =3 sbit  RFCE         = RFCON^0;
           =3 sbit  RFCSN        = RFCON^1;
           =3 sbit  RFCKEN       = RFCON^2;
           =3 
           =3 /* WDCON */
           =3 sbit  BD           = WDCON^7;
           =3 
           =3 /* AESCS */
           =3 sbit  GO           = AESCS^0;
           =3 sbit  DECR         = AESCS^1;
           =3 
           =3 /*lint +e18 */  /* Re-enable Lint warning 18 */
           =3 
           =3 
           =3 /* REGX commands */
           =3 #define RWD         0x00
           =3 #define WWD         0x08
           =3 #define RGTIMER     0x01
           =3 #define WGTIMER     0x09
           =3 #define RRTCLAT     0x02
           =3 #define WRTCLAT     0x0A
           =3 #define RRTC        0x03
           =3 #define WRTCDIS     0x0B
           =3 #define RWSTA0      0x04
           =3 #define WWCON0      0x0C
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 43  

           =3 #define RWSTA1      0x05
           =3 #define WWCON1      0x0D
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Interrupt Vector Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
           =3 #define INTERRUPT_T0           1   // Timer0 Overflow
           =3 #define INTERRUPT_AES_RDY      2   // AES ready interrupt
           =3 #define INTERRUPT_T1           3   // Timer1 Overflow
           =3 #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
           =3 #define INTERRUPT_T2           5   // Timer2 Overflow
           =3 #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
           =3 #define INTERRUPT_RFIRQ        9   // RF interrupt
           =3 #define INTERRUPT_SPI          10  // SPI interrupt
           =3 #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
           =3 #define INTERRUPT_USB_INT      12  // USB interrupt
           =3 #define INTERRUPT_WU           13  // Internal wakeup interrupt
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File Preprocessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif
  27      =2  
  28      =2  /** Macro that set radio's CSN line LOW.
  29      =2   *
  30      =2   */
  31      =2  #define CSN_LOW() do { RFCSN = 0; } while(0)
  32      =2  
  33      =2  /** Macro that set radio's CSN line HIGH.
  34      =2   *
  35      =2   */
  36      =2  #define CSN_HIGH() do { RFCSN = 1; } while(0)
  37      =2  
  38      =2  /** Macro that set radio's CE line LOW.
  39      =2   *
  40      =2   */
  41      =2  #define CE_LOW() do { RFCE = 0; } while(0)
  42      =2  
  43      =2  /** Macro that set radio's CE line HIGH.
  44      =2   *
  45      =2   */
  46      =2  #define CE_HIGH() do { RFCE = 1; } while(0)
  47      =2  
  48      =2  /** Macro for writing the radio SPI data register.
  49      =2   *
  50      =2   */
  51      =2  #define HAL_NRF_HW_SPI_WRITE(d) do{RFDAT = d; RFSPIF = 0;} while(0)
  52      =2  
  53      =2  /** Macro for reading the radio SPI data register.
  54      =2   *
  55      =2   */
  56      =2  #define HAL_NRF_HW_SPI_READ() RFDAT
  57      =2    
  58      =2  /** Macro specifyng the radio SPI busy flag.
  59      =2   *
  60      =2   */
  61      =2  #define HAL_NRF_HW_SPI_BUSY (!RFSPIF)
  62      =2  
  63      =2  /**
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 44  

  64      =2   * Pulses the CE to nRF24L01 for at least 10 us
  65      =2   */
  66      =2  #define CE_PULSE() do { \
  67      =2    uint8_t count; \
  68      =2    count = 20; \
  69      =2    CE_HIGH();  \
  70      =2    while(count--) \
  71      =2      ; \
  72      =2    CE_LOW();  \
  73      =2    } while(0)
  74      =2  
  75      =2  
  76      =2  #endif // HAL_NRF_LU1_H__
  77      =2  
  78      =2  /** @} */
  49      =1  
  50      =1  
  51      =1  uint8_t hal_nrf_write_reg(uint8_t data reg, uint8_t data value);
  52      =1  /** @name Setup */
  53      =1  //@{
  54      =1  /* Setup function prototypes */
  55      =1  
  56      =1  /** Enable or disable interrupt for radio.
  57      =1   * Use this function to enable or disable
  58      =1   * one of the interrupt sources for the radio.
  59      =1   * This function only changes state for selected
  60      =1   * int_type, the rest of the interrupt sources
  61      =1   * are left unchanged.
  62      =1   *
  63      =1   * @param int_source Radio interrupt Source.
  64      =1   * @param irq_state Enable or Disable.
  65      =1  */
  66      =1  void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state);
  67      =1  
  68      =1  /* For the obsolete nRF24L01 it is necessary to issue an activate command before the
  69      =1   * features enabled by the FEATURE register can be used. For nRF24L01+ these features
  70      =1   * are by default enabled.
  71      =1  */
  72      =1  void hal_nrf_activate_features(void);
  73      =1  
  74      =1  /** Enables the dynamic packet length
  75      =1   * @param enable Whether enable or disable dynamic packet length
  76      =1   */
  77      =1  void hal_nrf_enable_dynamic_payload(bool enable);
  78      =1  
  79      =1  /** Enables the ACK payload feature
  80      =1   * @param enable Whether to enable or disable ACK payload
  81      =1   */
  82      =1  void hal_nrf_enable_ack_payload(bool enable);
  83      =1  
  84      =1  /** Enables the dynamic ack feature
  85      =1   * @param enable Whether to enable or disable Dynamic ACK
  86      =1   */
  87      =1  void hal_nrf_enable_dynamic_ack(bool enable);
  88      =1  
  89      =1  /** Function for enabling dynmic payload size.
  90      =1   * The input parameter contains is a byte where the bit values tells weather the
  91      =1   * pipe should use dynamic payload size. For example if bit 0 is set then 
  92      =1   * pipe 0 will accept dynamic payload size.
  93      =1   * @param setup Byte value telling for which pips(s) to enable dynamic payload size
  94      =1   */
  95      =1  void hal_nrf_setup_dynamic_payload(uint8_t setup);
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 45  

  96      =1  
  97      =1  /** Reads the payload width of the received ack payload
  98      =1   * @return Payload width of the received ack payload
  99      =1   */
 100      =1  uint8_t hal_nrf_read_rx_payload_width(void);
 101      =1  
 102      =1  /** Write ack payload
 103      =1   * Writes the payload that will be transmitted with the ack on the given pipe.
 104      =1   * @param pipe Pipe that transmits the payload
 105      =1   * @param tx_pload Pointer to the payload data
 106      =1   * @param length Size of the data to transmit
 107      =1   */
 108      =1  void hal_nrf_write_ack_payload(uint8_t pipe, const uint8_t data *tx_pload, uint8_t data length);
 109      =1  
 110      =1  /** Read then clears all interrupt flags.
 111      =1   * Use this function to get the interrupt flags and clear them in the same operation.
 112      =1   * Reduced radio interface activity and speed optimized.
 113      =1   *
 114      =1   * @return  Interrupt_flags
 115      =1   * @retval 0x10 Max Retransmit interrupt
 116      =1   * @retval 0x20 TX Data sent interrupt
 117      =1   * @retval 0x40 RX Data received interrupt
 118      =1  */
 119      =1  uint8_t hal_nrf_get_clear_irq_flags(void);
 120      =1  
 121      =1  /** Clear one selected interrupt flag.
 122      =1   * Use this function to clear one @a spesific interrupt flag.
 123      =1   * Other interrupt flags are left unchanged.
 124      =1   *
 125      =1   * @param int_source Interrupt source of which flag to clear
 126      =1  */
 127      =1  void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source);
 128      =1  
 129      =1  /** Set the CRC mode used by the radio.
 130      =1   * Use this function to set the CRC mode; CRC disabled, 1 or 2 bytes.
 131      =1   *
 132      =1   * @param crc_mode CRC mode to use
 133      =1  */
 134      =1  void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode);
 135      =1  
 136      =1  /** Open radio pipe(s) and enable/ disable auto acknowledge.
 137      =1   * Use this function to open one or all pipes,
 138      =1   * with or without auto acknowledge.
 139      =1   *
 140      =1   * @param pipe_num Radio pipe to open
 141      =1   * @param auto_ack Auto_Ack ON/OFF
 142      =1   * @see hal_nrf_address
 143      =1  */
 144      =1  void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack);
 145      =1  
 146      =1  /** Close radio pipe(s).
 147      =1   * Use this function to close one pipe or all pipes.
 148      =1   *
 149      =1   * @param pipe_num Pipe# number to close
 150      =1  */
 151      =1  void hal_nrf_close_pipe(hal_nrf_address_t pipe_num);
 152      =1  
 153      =1  /** Set radio's RX address and TX address.
 154      =1   * Use this function to set a RX address, or to set the TX address.
 155      =1   * Beware of the difference for single and multibyte address registers.
 156      =1   *
 157      =1   * @param address Which address to set
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 46  

 158      =1   * @param *addr Buffer from which the address is stored in
 159      =1  */
 160      =1  void hal_nrf_set_address(const hal_nrf_address_t address, const uint8_t *addr);
 161      =1  
 162      =1  /** Get address for selected pipe.
 163      =1   * Use this function to get address for selected pipe.
 164      =1   *
 165      =1   *
 166      =1   * @param address Which address to get, Pipe- or TX-address
 167      =1   * @param *addr buffer in which address bytes are written.
 168      =1   * <BR><BR>For pipes containing only LSB byte of address, this byte is returned
 169      =1   * in the<BR> *addr buffer.
 170      =1   *
 171      =1   * @return Numbers of bytes copied to addr
 172      =1  */
 173      =1  uint8_t hal_nrf_get_address (uint8_t address, uint8_t *addr);
 174      =1  
 175      =1  /** Set auto acknowledge parameters.
 176      =1   * Use this function to set retransmit and retransmit delay
 177      =1   * parameters.
 178      =1   *
 179      =1   * @param retr Number of retransmit, 0 equ retransmit OFF
 180      =1   * @param delay Retransmit delay in s. Must be a 
 181      =1  */
 182      =1  void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay);
 183      =1  
 184      =1  /** Set radio's address width.
 185      =1   * Use this function to define the radio's address width,
 186      =1   * referes to both RX and TX.
 187      =1   *
 188      =1   * @param address_width Address with in bytes
 189      =1  */
 190      =1  void hal_nrf_set_address_width(hal_nrf_address_width_t address_width);
 191      =1  
 192      =1  /** Gets the radio's address width.
 193      =1   *
 194      =1   * @return Address width
 195      =1   */
 196      =1  uint8_t hal_nrf_get_address_width (void);
 197      =1  
 198      =1  /** Set payload width for selected pipe.
 199      =1   * Use this function to set the number of bytes expected
 200      =1   * on a selected pipe.
 201      =1   *
 202      =1   * @param pipe_num Pipe number to set payload width for
 203      =1   * @param pload_width number of bytes expected
 204      =1  */
 205      =1  void hal_nrf_set_rx_payload_width(uint8_t pipe_num, uint8_t pload_width);
 206      =1  
 207      =1  /** Read current interrupt mode for selected interrupt source.
 208      =1   * Use this function to get the interrupt source's mode,
 209      =1   * either enabled or disabled.
 210      =1   *
 211      =1   * @param int_source Interrupt source to get mode from
 212      =1   *
 213      =1   * @return Interrupt Mode
 214      =1   * @retval FALSE Interrupt disabled
 215      =1   * @retval TRUE Interrupt enabled
 216      =1  */
 217      =1  bool hal_nrf_get_irq_mode(uint8_t int_source);
 218      =1  
 219      =1  /** Read all interrupt flags.
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 47  

 220      =1   * Use this function to get the interrupt flags. This function is similar
 221      =1   * to hal_nrf_get_clear_irq_flags with the exception that it does <I><B>NOT</B></I> clear
 222      =1   * the irq_flags.
 223      =1   *
 224      =1   * @return Interrupt_flags
 225      =1   * @retval 0x10 Max Retransmit interrupt
 226      =1   * @retval 0x20 TX Data sent interrupt
 227      =1   * @retval 0x40 RX Data received interrupt
 228      =1  */
 229      =1  uint8_t hal_nrf_get_irq_flags(void);
 230      =1  
 231      =1  /** Get pipe status.
 232      =1   * Use this function to check status for a selected pipe.
 233      =1   *
 234      =1   * @param  pipe_num Pipe number to check status for
 235      =1   *
 236      =1   * @return Pipe_Status
 237      =1   * @retval 0x00 Pipe is closed, autoack disabled
 238      =1   * @retval 0x01 Pipe is open, autoack disabled
 239      =1   * @retval 0x03 Pipe is open, autoack enabled
 240      =1  */
 241      =1  uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num);
 242      =1  
 243      =1  /** Get auto retransmit parameters.
 244      =1   * Use this function to get the auto retransmit parameters,
 245      =1   * retrans count and retrans delay.
 246      =1   *
 247      =1   * @return AutoRetrans Parameters
 248      =1   *
 249      =1   * @retval UpperNibble Retransmit Delay
 250      =1   * @retval LowerNibble Retransmit Count
 251      =1  */
 252      =1  uint8_t hal_nrf_get_auto_retr_status(void);
 253      =1  
 254      =1  /** Get packet lost counter
 255      =1   * Use this function to get the packet(s) counter.
 256      =1   *
 257      =1   * @return packet lost counter
 258      =1  */
 259      =1  uint8_t hal_nrf_get_packet_lost_ctr(void);
 260      =1  
 261      =1  /** Get RX payload width for selected pipe.
 262      =1   * Use this function to get the expected payload
 263      =1   * width for selected ppe number.
 264      =1   *
 265      =1   * @param pipe_num Pipe number to get payload width for
 266      =1   *
 267      =1   * @return Payload_Width in bytes                                                                                                                                       
 268      =1  */
 269      =1  uint8_t hal_nrf_get_rx_payload_width(uint8_t pipe_num);
 270      =1  //@}
 271      =1  
 272      =1  /** @name Operation */
 273      =1  //@{
 274      =1  /* Operation function prototypes */
 275      =1  
 276      =1  /** Set radio's operation mode.
 277      =1   * Use this function to enter PTX (primary TX)
 278      =1   * or PRX (primary RX).
 279      =1   *
 280      =1   * @param op_mode Operation mode
 281      =1  */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 48  

 282      =1  void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode);
 283      =1  
 284      =1  /** Set radio's power mode.
 285      =1   * Use this function to power_up or power_down radio.
 286      =1   *
 287      =1   * @param pwr_mode POWER_UP or POWER_DOWN
 288      =1  */
 289      =1  void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode);
 290      =1  
 291      =1  /** Set radio's RF channel.
 292      =1   * Use this function to select which RF channel to use.
 293      =1   *
 294      =1   * @param channel RF channel
 295      =1  */
 296      =1  void hal_nrf_set_rf_channel(uint8_t channel);
 297      =1  
 298      =1  /** Set radio's TX output power.
 299      =1   * Use this function set the radio's TX output power.
 300      =1   *
 301      =1   * @param power Radio's TX output power
 302      =1  */
 303      =1  void hal_nrf_set_output_power(hal_nrf_output_power_t power);
 304      =1  
 305      =1  /** Set radio's on-air datarate.
 306      =1   * Use this function to select radio's on-air
 307      =1   * datarate.
 308      =1   *
 309      =1   * @param datarate On-air datarate
 310      =1  */
 311      =1  void hal_nrf_set_datarate(hal_nrf_datarate_t datarate);
 312      =1  
 313      =1  
 314      =1  /* Status functions prototypes */
 315      =1  
 316      =1  /** Get radio's TX FIFO status.
 317      =1   * Use this function to get the radio's TX
 318      =1   * FIFO status.
 319      =1   *
 320      =1   * @return TX FIFO status
 321      =1   * @retval 0x00 TX FIFO NOT empty, but NOT full
 322      =1   * @retval 0x01 FIFO empty
 323      =1   * @retval 0x02 FIFO full
 324      =1   *
 325      =1  */
 326      =1  uint8_t hal_nrf_get_tx_fifo_status(void);
 327      =1  
 328      =1  /** Check for TX FIFO empty.
 329      =1   * Use this function to check if TX FIFO
 330      =1   * is empty.
 331      =1   *
 332      =1   * @return TX FIFO empty bit
 333      =1   * @retval FALSE TX FIFO NOT empty
 334      =1   * @retval TRUE TX FIFO empty
 335      =1   *
 336      =1  */
 337      =1  bool hal_nrf_tx_fifo_empty(void);
 338      =1  
 339      =1  /** Check for TX FIFO full.
 340      =1   * Use this function to check if TX FIFO
 341      =1   * is full.
 342      =1   *
 343      =1   * @return TX FIFO full bit
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 49  

 344      =1   * @retval FALSE TX FIFO NOT full
 345      =1   * @retval TRUE TX FIFO full
 346      =1   *
 347      =1  */
 348      =1  bool hal_nrf_tx_fifo_full(void);
 349      =1  
 350      =1  /** Get radio's RX FIFO status.
 351      =1   * Use this function to get the radio's TX
 352      =1   * FIFO status.
 353      =1   *
 354      =1   * @return RX FIFO status
 355      =1   * @retval 0x00 RX FIFO NOT empty, but NOT full
 356      =1   * @retval 0x01 RX FIFO empty
 357      =1   * @retval 0x02 RX FIFO full
 358      =1   *
 359      =1  */
 360      =1  uint8_t hal_nrf_get_rx_fifo_status(void);
 361      =1  
 362      =1  /** Check for RX FIFO empty.
 363      =1   * Use this function to check if RX FIFO
 364      =1   * is empty.
 365      =1   *
 366      =1   * Reads STATUS register to check this, not FIFO_STATUS  
 367      =1   *
 368      =1   * @return RX FIFO empty bit
 369      =1   * @retval FALSE RX FIFO NOT empty
 370      =1   * @retval TRUE RX FIFO empty
 371      =1   *
 372      =1  */
 373      =1  bool hal_nrf_rx_fifo_empty(void);
 374      =1  
 375      =1  /** Check for RX FIFO full.
 376      =1   * Use this function to check if RX FIFO
 377      =1   * is full.
 378      =1   *
 379      =1   * @return RX FIFO full bit
 380      =1   * @retval FALSE RX FIFO NOT full
 381      =1   * @retval TRUE RX FIFO full
 382      =1   *
 383      =1  */
 384      =1  bool hal_nrf_rx_fifo_full(void);
 385      =1  
 386      =1  /** Get radio's transmit attempts status.
 387      =1   * Use this function to get number of retransmit
 388      =1   * attempts and number of packet lost.
 389      =1   *
 390      =1   * @return Retransmit attempts counters
 391      =1  */
 392      =1  uint8_t hal_nrf_get_transmit_attempts(void);
 393      =1  
 394      =1  /** Get the carrier detect flag.
 395      =1   * Use this function to get the carrier detect flag,
 396      =1   * used to detect stationary disturbance on selected
 397      =1   * RF channel.
 398      =1   *
 399      =1   * @return Carrier Detect
 400      =1   * @retval FALSE Carrier NOT Detected
 401      =1   * @retval TRUE Carrier Detected
 402      =1  */
 403      =1  bool hal_nrf_get_carrier_detect(void);
 404      =1  
 405      =1  /* Data operation prototypes */
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 50  

 406      =1  
 407      =1  /** Get RX data source.
 408      =1   * Use this function to read which RX pipe data
 409      =1   * was received on for current top level FIFO data packet.
 410      =1   *
 411      =1   * @return pipe number of current packet present
 412      =1  */
 413      =1  uint8_t hal_nrf_get_rx_data_source(void);
 414      =1  
 415      =1  /** Read RX payload.
 416      =1   * Use this function to read top level payload
 417      =1   * available in the RX FIFO.
 418      =1   *
 419      =1   * @param  *rx_pload pointer to buffer in which RX payload are stored
 420      =1   * @return pipe number (MSB byte) and packet length (LSB byte)
 421      =1  */
 422      =1  
 423      =1  uint16_t hal_nrf_read_rx_payload(uint8_t data *rx_pload);
 424      =1  uint16_t hal_nrf_read_multibyte_reg(uint8_t data reg, uint8_t data *pbuf);
 425      =1  
 426      =1  
 427      =1  /** Write TX payload to radio.
 428      =1   * Use this function to write a packet of
 429      =1   * TX payload into the radio.
 430      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 431      =1   *
 432      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 433      =1   * @param length number of bytes to write
 434      =1  */
 435      =1  void hal_nrf_write_tx_payload(const uint8_t data *tx_pload, uint8_t data length);
 436      =1  
 437      =1  /** Write TX payload which do not require ACK. When transmitting 
 438      =1   * a ACK is not required nor sent from the receiver. The payload will
 439      =1   * always be assumed as "sent".
 440      =1   *
 441      =1   * Use this function to write a packet of
 442      =1   * TX payload into the radio.
 443      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 444      =1   *
 445      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 446      =1   * @param length number of bytes to write
 447      =1  */
 448      =1  void hal_nrf_write_tx_payload_noack(const uint8_t data *tx_pload, uint8_t data length);
 449      =1  
 450      =1  /** Reuse TX payload.
 451      =1   * Use this function to set that the radio is using
 452      =1   * the last transmitted payload for the next packet as well.
 453      =1   *
 454      =1  */
 455      =1  void hal_nrf_reuse_tx(void);
 456      =1  
 457      =1  /** Get status of reuse TX function.
 458      =1   * Use this function to check if reuse TX payload is
 459      =1   * activated
 460      =1   *
 461      =1   * @return Reuse TX payload mode
 462      =1   * @retval FALSE Not activated
 463      =1   * @retval TRUE Activated
 464      =1  */
 465      =1  bool hal_nrf_get_reuse_tx_status(void);
 466      =1  
 467      =1  /** Flush RX FIFO.
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 51  

 468      =1   * Use this function to flush the radio's
 469      =1   * RX FIFO.
 470      =1   *
 471      =1  */
 472      =1  void hal_nrf_flush_rx(void);
 473      =1  
 474      =1  /** Flush TX FIFO.
 475      =1   * Use this function to flush the radio's
 476      =1   * TX FIFO.
 477      =1   *
 478      =1  */
 479      =1  void hal_nrf_flush_tx(void);
 480      =1  
 481      =1  /** No Operation command.
 482      =1   * Use this function to receive the radio's
 483      =1   * status register.
 484      =1   *
 485      =1   * @return Status register
 486      =1  */
 487      =1  uint8_t hal_nrf_nop(void);
 488      =1  //@}
 489      =1  
 490      =1  /** @name  Test */
 491      =1  //@{
 492      =1  /* Test functions prototypes */
 493      =1  
 494      =1  /** Set radio's PLL mode.
 495      =1   * Use this function to either LOCK
 496      =1   * or UNLOCK the radio's PLL.
 497      =1   *
 498      =1   * @param pll_lock PLL locked, TRUE or FALSE
 499      =1  */
 500      =1  void hal_nrf_set_pll_mode(bool pll_lock);
 501      =1  
 502      =1  /** Set radio's LNA gain mode.
 503      =1   * Use this function to either use HI
 504      =1   * current or LOW current mode for the radio.
 505      =1   *
 506      =1   * @param lna_gain LNA gain mode
 507      =1  */
 508      =1  void hal_nrf_set_lna_gain(bool lna_gain);
 509      =1  
 510      =1  /** Enables continuous carrier transmit.
 511      =1   * Use this function to enable or disable
 512      =1   * continuous carrier transmission.
 513      =1   * @param enable Enable continuous carrier
 514      =1   */
 515      =1  void hal_nrf_enable_continious_wave (bool enable);
 516      =1  
 517      =1  /* hal_nrf_l01 basic functions, used by all the other functions */
 518      =1  
 519      =1  //@}
 520      =1  
 521      =1  /** @name SPI interface */
 522      =1  //@{
 523      =1  
 524      =1  /** Basis function, nrf_rw
 525      =1   * This function is used by the basis functions
 526      =1   * to exchange data with the data.
 527      =1   *
 528      =1   * @param value Databyte to write
 529      =1   *
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 52  

 530      =1   * @return Databyte from radio.
 531      =1  */
 532      =1  uint8_t hal_nrf_rw(uint8_t value);
 533      =1  //@}
 534      =1  #endif // HAL_NRF_H__
 535      =1  /** @} */
 536      =1  
  18          #include "hal_nrf_hw.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1  * @brief hal_nrf macros for nRF24LU1+
  16      =1   *
  17      =1   * @defgroup hal_nrf24lu1p_hal_nrf_hw hal_nrf_hw
  18      =1   * @{
  19      =1   * @ingroup hal_nrf24lu1p
  20      =1   *
  21      =1   */
  22      =1  
  23      =1  #ifndef HAL_NRF_LU1_H__
           =1 #define HAL_NRF_LU1_H__
           =1 
           =1 #include <Nordic\reg24lu1.h>
           =1 
           =1 /** Macro that set radio's CSN line LOW.
           =1  *
           =1  */
           =1 #define CSN_LOW() do { RFCSN = 0; } while(0)
           =1 
           =1 /** Macro that set radio's CSN line HIGH.
           =1  *
           =1  */
           =1 #define CSN_HIGH() do { RFCSN = 1; } while(0)
           =1 
           =1 /** Macro that set radio's CE line LOW.
           =1  *
           =1  */
           =1 #define CE_LOW() do { RFCE = 0; } while(0)
           =1 
           =1 /** Macro that set radio's CE line HIGH.
           =1  *
           =1  */
           =1 #define CE_HIGH() do { RFCE = 1; } while(0)
           =1 
           =1 /** Macro for writing the radio SPI data register.
           =1  *
           =1  */
           =1 #define HAL_NRF_HW_SPI_WRITE(d) do{RFDAT = d; RFSPIF = 0;} while(0)
           =1 
           =1 /** Macro for reading the radio SPI data register.
           =1  *
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 53  

           =1  */
           =1 #define HAL_NRF_HW_SPI_READ() RFDAT
           =1   
           =1 /** Macro specifyng the radio SPI busy flag.
           =1  *
           =1  */
           =1 #define HAL_NRF_HW_SPI_BUSY (!RFSPIF)
           =1 
           =1 /**
           =1  * Pulses the CE to nRF24L01 for at least 10 us
           =1  */
           =1 #define CE_PULSE() do { \
           =1   uint8_t count; \
           =1   count = 20; \
           =1   CE_HIGH();  \
           =1   while(count--) \
           =1     ; \
           =1   CE_LOW();  \
           =1   } while(0)
           =1 
           =1 
           =1 #endif // HAL_NRF_LU1_H__
  77      =1  
  78      =1  /** @} */
  19          
  20          #include "usb_map.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief USB register layout and interrupts
  16      =1   *
  17      =1   * This file contain:
  18      =1   * - the USB-controller register layout
  19      =1   * - the USB-controller interrupts towards the MCU
  20      =1   *
  21      =1   * The usb_map_t structure is set to point at xdata address 0x0000
  22      =1   */
  23      =1  #ifndef USB_MAP_H__
  24      =1  #define USB_MAP_H__
  25      =1  
  26      =1  #ifdef ALLOCATE_USB_MAP
           =1 #define EXTERN
           =1 #define _AT_ _at_
           =1 #else
  30      =1  #define EXTERN extern
  31      =1  #define _AT_ ;/ ## /
  32      =1  #endif
  33      =1  
  34      =1  #define USB_EP_DEFAULT_BUF_SIZE 0x20 // (32)
  35      =1  
  36      =1  EXTERN xdata volatile uint8_t out5buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC440;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 54  

  37      =1  EXTERN xdata volatile uint8_t in5buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC480;
  38      =1  EXTERN xdata volatile uint8_t out4buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC4C0;
  39      =1  EXTERN xdata volatile uint8_t in4buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC500;
  40      =1  EXTERN xdata volatile uint8_t out3buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC540;
  41      =1  EXTERN xdata volatile uint8_t in3buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC580;
  42      =1  EXTERN xdata volatile uint8_t out2buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC5C0;
  43      =1  EXTERN xdata volatile uint8_t in2buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC600;
  44      =1  EXTERN xdata volatile uint8_t out1buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC640;
  45      =1  EXTERN xdata volatile uint8_t in1buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC680;
  46      =1  EXTERN xdata volatile uint8_t out0buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC6C0;
  47      =1  EXTERN xdata volatile uint8_t in0buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC700;
  48      =1  EXTERN xdata volatile uint8_t out8data                         _AT_ 0xC760;
  49      =1  EXTERN xdata volatile uint8_t in8data                          _AT_ 0xC768;
  50      =1  EXTERN xdata volatile uint8_t out8bch                          _AT_ 0xC770;
  51      =1  EXTERN xdata volatile uint8_t out8bcl                          _AT_ 0xC771;
  52      =1  EXTERN xdata volatile uint8_t bout1addr                        _AT_ 0xC781;
  53      =1  EXTERN xdata volatile uint8_t bout2addr                        _AT_ 0xC782;
  54      =1  EXTERN xdata volatile uint8_t bout3addr                        _AT_ 0xC783;
  55      =1  EXTERN xdata volatile uint8_t bout4addr                        _AT_ 0xC784;
  56      =1  EXTERN xdata volatile uint8_t bout5addr                        _AT_ 0xC785;
  57      =1  EXTERN xdata volatile uint8_t binstaddr                        _AT_ 0xC788;
  58      =1  EXTERN xdata volatile uint8_t bin1addr                         _AT_ 0xC789;
  59      =1  EXTERN xdata volatile uint8_t bin2addr                         _AT_ 0xC78A;
  60      =1  EXTERN xdata volatile uint8_t bin3addr                         _AT_ 0xC78B;
  61      =1  EXTERN xdata volatile uint8_t bin4addr                         _AT_ 0xC78C;
  62      =1  EXTERN xdata volatile uint8_t bin5addr                         _AT_ 0xC78D;
  63      =1  EXTERN xdata volatile uint8_t isoerr                           _AT_ 0xC7A0;
  64      =1  EXTERN xdata volatile uint8_t zbcout                           _AT_ 0xC7A2;
  65      =1  EXTERN xdata volatile uint8_t ivec                             _AT_ 0xC7A8;
  66      =1  EXTERN xdata volatile uint8_t in_irq                           _AT_ 0xC7A9;
  67      =1  EXTERN xdata volatile uint8_t out_irq                          _AT_ 0xC7AA;
  68      =1  EXTERN xdata volatile uint8_t usbirq                           _AT_ 0xC7AB;
  69      =1  EXTERN xdata volatile uint8_t in_ien                           _AT_ 0xC7AC;
  70      =1  EXTERN xdata volatile uint8_t out_ien                          _AT_ 0xC7AD;
  71      =1  EXTERN xdata volatile uint8_t usbien                           _AT_ 0xC7AE;
  72      =1  EXTERN xdata volatile uint8_t usbbav                           _AT_ 0xC7AF;
  73      =1  EXTERN xdata volatile uint8_t ep0cs                            _AT_ 0xC7B4;
  74      =1  EXTERN xdata volatile uint8_t in0bc                            _AT_ 0xC7B5;
  75      =1  EXTERN xdata volatile uint8_t in1cs                            _AT_ 0xC7B6;
  76      =1  EXTERN xdata volatile uint8_t in1bc                            _AT_ 0xC7B7;
  77      =1  EXTERN xdata volatile uint8_t in2cs                            _AT_ 0xC7B8;
  78      =1  EXTERN xdata volatile uint8_t in2bc                            _AT_ 0xC7B9;
  79      =1  EXTERN xdata volatile uint8_t in3cs                            _AT_ 0xC7BA;
  80      =1  EXTERN xdata volatile uint8_t in3bc                            _AT_ 0xC7BB;
  81      =1  EXTERN xdata volatile uint8_t in4cs                            _AT_ 0xC7BC;
  82      =1  EXTERN xdata volatile uint8_t in4bc                            _AT_ 0xC7BD;
  83      =1  EXTERN xdata volatile uint8_t in5cs                            _AT_ 0xC7BE;
  84      =1  EXTERN xdata volatile uint8_t in5bc                            _AT_ 0xC7BF;
  85      =1  EXTERN xdata volatile uint8_t out0bc                           _AT_ 0xC7C5;
  86      =1  EXTERN xdata volatile uint8_t out1cs                           _AT_ 0xC7C6;
  87      =1  EXTERN xdata volatile uint8_t out1bc                           _AT_ 0xC7C7;
  88      =1  EXTERN xdata volatile uint8_t out2cs                           _AT_ 0xC7C8;
  89      =1  EXTERN xdata volatile uint8_t out2bc                           _AT_ 0xC7C9;
  90      =1  EXTERN xdata volatile uint8_t out3cs                           _AT_ 0xC7CA;
  91      =1  EXTERN xdata volatile uint8_t out3bc                           _AT_ 0xC7CB;
  92      =1  EXTERN xdata volatile uint8_t out4cs                           _AT_ 0xC7CC;
  93      =1  EXTERN xdata volatile uint8_t out4bc                           _AT_ 0xC7CD;
  94      =1  EXTERN xdata volatile uint8_t out5cs                           _AT_ 0xC7CE;
  95      =1  EXTERN xdata volatile uint8_t out5bc                           _AT_ 0xC7CF;
  96      =1  EXTERN xdata volatile uint8_t usbcs                            _AT_ 0xC7D6;
  97      =1  EXTERN xdata volatile uint8_t togctl                           _AT_ 0xC7D7;
  98      =1  EXTERN xdata volatile uint8_t usbfrml                          _AT_ 0xC7D8;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 55  

  99      =1  EXTERN xdata volatile uint8_t usbfrmh                          _AT_ 0xC7D9;
 100      =1  EXTERN xdata volatile uint8_t fnaddr                           _AT_ 0xC7DB;
 101      =1  EXTERN xdata volatile uint8_t usbpair                          _AT_ 0xC7DD;
 102      =1  EXTERN xdata volatile uint8_t inbulkval                        _AT_ 0xC7DE;
 103      =1  EXTERN xdata volatile uint8_t outbulkval                       _AT_ 0xC7DF;
 104      =1  EXTERN xdata volatile uint8_t inisoval                         _AT_ 0xC7E0;
 105      =1  EXTERN xdata volatile uint8_t outisoval                        _AT_ 0xC7E1;
 106      =1  EXTERN xdata volatile uint8_t isostaddr                        _AT_ 0xC7E2;
 107      =1  EXTERN xdata volatile uint8_t isosize                          _AT_ 0xC7E3;
 108      =1  EXTERN xdata volatile uint8_t setupbuf[8]                      _AT_ 0xC7E8;
 109      =1  EXTERN xdata volatile uint8_t out8addr                         _AT_ 0xC7F0;
 110      =1  EXTERN xdata volatile uint8_t in8addr                          _AT_ 0xC7F8;
 111      =1  
 112      =1  #endif
  21          
  22          #define SIZEOFPROG 11
  23          #define PKTLENGTH 32
  24          
  25           // Calculate buffer location in USB-controller
  26          #define CALCULATE_BUF_IN_PTR(ep) (uint8_t xdata *)(in0buf - (( ep & 0x7f) * 128))
  27          #define CALCULATE_BUF_OUT_PTR(ep) (uint8_t xdata *)(out0buf - (ep * 128 ))
  28          
  29          // Calculate byte count register location in USB-controller
  30          #define CALCULATE_BC_OUT_PTR(ep) (uint8_t xdata *)(&out0bc + (ep * 2 ))
  31          #define CALCULATE_BC_IN_PTR(ep) (uint8_t xdata *)(&in0bc + ((ep & 0x7f ) * 2))
  32          
  33          #define MSB(x) (x>>8)
*** WARNING C317 IN LINE 33 OF main.c: attempt to redefine macro 'MSB'
  34          #define LSB(x) (x&(0xFF))
*** WARNING C317 IN LINE 34 OF main.c: attempt to redefine macro 'LSB'
  35          
  36          static hal_usb_dev_req_resp_t device_req_cb(hal_usb_device_req* req, uint8_t** data_ptr, uint16_t* size) r
             -eentrant;   
  37          static void suspend_cb(uint8_t allow_remote_wu) reentrant;   
  38          static void resume_cb() reentrant;   
  39          static void reset_cb() reentrant;   
  40          static code uint8_t ep_1_in_cb(uint8_t *adr_ptr, uint8_t* size) reentrant;   
  41          //static code uint8_t ep_1_out_cb(uint8_t *adr_ptr, uint8_t* size) reentrant; 
  42          
  43          static void usb_process_get_descriptor(hal_usb_device_req* req, uint8_t** data_ptr, uint16_t* size, hal_us
             -b_dev_req_resp_t* resp);
  44          static void usb_wait_for_configuration(void);
  45          static void radio_init();
  46           
  47          //app_states_t app_susp_wd(void); 
  48          
  49          typedef enum 
  50          { 
  51           USB_AWAKE, 
  52           USB_REM_WU_ENABLE, 
  53           USB_REM_WU_DISABLE, 
  54          } usb_state_t; 
  55          
  56          typedef enum   
  57          { 
  58            APP_INIT = 0,     
  59            APP_NORMAL,   
  60            APP_SUSP_WE ,   
  61            APP_SUSP_WD,     
  62          } app_states_t;   
  63          
  64          app_states_t app_init(void);
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 56  

  65          static app_states_t app_normal(void);   
  66          app_states_t app_susp_we(void);  
  67          usb_state_t usb_get_state();
  68          
  69          void usb_wakeup(void);
  70           
  71          static data volatile usb_state_t usb_state;
  72          static bool ep1_sent, ep2_sent, ep2_rx; 
  73          static uint8_t *e_arr;
  74          static uint8_t e_size;
  75          // Global variables
  76          data bool radio_busy;
  77          //data uint8_t temp = 0;
  78          data uint8_t block = 0;
  79          data uint8_t byteCnt = 0;
  80          data uint8_t blockAcquired = 0;
  81          data uint8_t blockNeedsSending = 0;
  82          data uint8_t payload[2][PKTLENGTH];
  83          
  84          
  85          uint8_t data ackPayload[SIZEOFPROG];
  86          // uint8_t payload[2][30];
  87            sbit P0_0 = P0^0;
  88            sbit P0_4 = P0^4;
  89            sbit P0_5 = P0^5;
  90            sbit P0_6 = P0^6;
  91            sbit P0_7 = P0^7;
  92          
  93          void main(void) 
  94          {
  95   1              data app_states_t app_state = APP_INIT;  
  96   1              CLKCTL = 0;                                 // Reset clock control register
  97   1              P0DIR = (1<<3)|(1<<1)|(1<<0);
  98   1      //      P0DIR = 0x18;                               // Output: P0.0 - P0.2, Input: P0.3 - P0.5   
  99   1        //    P0ALT = 0;                                  // All general I/O   
 100   1        //    P0 = 0;
 101   1         /* 
 102   1               P0ALT = 0x0F;
 103   1               P0EXP = 0x02; // Slave SPI for P0
 104   1               SSCONF = 0x01; //Enable slave SPI
 105   1               */
 106   1              CE_LOW();                                   // Radio chip enable low   
 107   1              RFCTL = 0x10;                               // Internal MCU to radio SPI enable    
 108   1              RFCKEN = 1;                                 // Radio clk enable   
 109   1              RF = 1;                                     // Radio IRQ enable
 110   1                                                                                      // Enable global interrupt
 111   1        
 112   1              /** USB-init **/
 113   1              usbpair |= 0x01;
 114   1              hal_usb_init(true, device_req_cb, reset_cb, resume_cb, suspend_cb);
 115   1              hal_usb_endpoint_config(0x82, 32, ep_1_in_cb);
 116   1              hal_usb_endpoint_config(0x02, 32, ep_1_out_cb);
 117   1              
 118   1              ep1_sent = true;   
 119   1              ep2_sent = true;   
 120   1              usb_state = USB_AWAKE;   
 121   1              
 122   1      
 123   1              EA = 1;
 124   1              usb_wait_for_configuration();               // Wait until USB enumerated
 125   1              
 126   1              byteCnt = PKTLENGTH;
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 57  

 127   1              
 128   1              payload[1][PKTLENGTH-1] = 0xAA;
 129   1              payload[0][PKTLENGTH-1] = 0xAA;
 130   1      
 131   1              for(;;)
 132   1              {
 133   2                      switch(app_state)
 134   2                      {
 135   3                        case APP_INIT:
 136   3                              app_state = app_init();
 137   3                              break;   
 138   3                    case APP_NORMAL:                                                        // Normal state   
 139   3                      app_state = app_normal();   
 140   3                      break;   
 141   3                    case APP_SUSP_WE:                                                       // PC suspend state, remote
             - wakeup enabled   
 142   3                    case APP_SUSP_WD:                                                       // PC suspend state, remote
             - wakeup disabled   
 143   3                     // P0_4=1;
 144   3                              app_state = app_susp_we();
 145   3                      //      P0_4=0;   
 146   3                      break;   
 147   3                    default:   
 148   3                      break;
 149   3                      }
 150   2              }
 151   1                
 152   1              return;
 153   1      }
 154          
 155          static app_states_t app_normal(void)   
 156          {
 157   1              usb_state_t data temp_state = usb_get_state();
 158   1               uint8_t i = 0;
 159   1           uint8_t xdata *buf_ptr;
 160   1           uint8_t xdata *bc_ptr;
 161   1      
 162   1              if(temp_state == USB_REM_WU_ENABLE)   
 163   1              {   
 164   2              return APP_SUSP_WE;    
 165   2              }   
 166   1             
 167   1              if(temp_state == USB_REM_WU_DISABLE)   
 168   1              {   
 169   2              return APP_SUSP_WD;    
 170   2              }
 171   1              
 172   1              if(ep2_rx) // process data we got over USB
 173   1              {
 174   2                      ep2_rx = false;
 175   2      
 176   2                      hal_nrf_write_ack_payload(0, ackPayload, SIZEOFPROG);
 177   2              //      hal_usb_send_data(2, "\x00\x00", 2);    
 178   2              }
 179   1      
 180   1              if(blockNeedsSending) // process data from Wireless
 181   1              {
 182   2                      blockNeedsSending = 0;
 183   2      
 184   2              /*   hal_usb_send_data(1,  payload[0], 31); */
 185   2                  P0_5=1;
 186   2          // Calculate the buffer pointer and byte count pointer
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 58  

 187   2      
 188   2                  buf_ptr = CALCULATE_BUF_IN_PTR(2);
 189   2                  bc_ptr = CALCULATE_BC_IN_PTR(2);
 190   2                      
 191   2                      if( 0 == block )
 192   2                      {
 193   3                      //      buf_ptr = buf_ptr + 31; 
 194   3                      }
 195   2                  // Copy the data into the USB controller
 196   2                  for( i = 0; i < PKTLENGTH; ++i )
 197   2                  {
 198   3                      buf_ptr[i] = payload[block][i];
 199   3                  }
 200   2          
 201   2      //          buf_ptr[30] = block + (0xAA);
 202   2              *bc_ptr = PKTLENGTH;
 203   2                      // Set the number of bytes we want to send to USB-host. This also trigger sending of data to USB-host.
 204   2              
 205   2      
 206   2                      if(block)
 207   2                      {
 208   3                              block = 0;
 209   3                      } else {
 210   3                              block = 1;
 211   3                      }
 212   2                      P0_5=0;
 213   2                      /********/
 214   2              /*
 215   2                      // Write payload to radio USB FIFO
 216   2              hal_usb_send_data(1, payload[(block^0x01)], 31);
 217   2                      blockNeedsSending = 0;*/
 218   2              }
 219   1               
 220   1              return APP_NORMAL; 
 221   1      }
 222          
 223          app_states_t app_init(void)
 224          {
 225   1              if(usb_get_state() == USB_REM_WU_ENABLE)   
 226   1              {   
 227   2              return APP_SUSP_WE;    
 228   2              }   
 229   1             
 230   1              if(usb_get_state() == USB_REM_WU_DISABLE)   
 231   1              {   
 232   2              return APP_SUSP_WD;    
 233   2              }
 234   1         /*
 235   1              I3FR = 1;             // rising edge SPI ready detect
 236   1              INTEXP = 0x01; //Slave SPI Interrupt
 237   1              SPI = 1; // Enable SPI Interrupt
 238   1               */
 239   1              hal_nrf_enable_ack_payload(1);
 240   1              hal_nrf_enable_dynamic_payload(1);
 241   1              hal_nrf_setup_dynamic_payload(1 << 0); // Set up PIPE 0 to handle dynamic lengths
 242   1              hal_nrf_set_operation_mode(HAL_NRF_PRX);                // Configure radio as primary receiver (PTX) 
 243   1              //hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, 30);      // Set payload width to 30 bytes
 244   1              hal_nrf_set_power_mode(HAL_NRF_PWR_UP);                 // Power up radio
 245   1              CE_HIGH();         // Enable receiver
 246   1              
 247   1              return APP_NORMAL;      
 248   1      }
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 59  

 249          
 250          app_states_t app_susp_we(void)   
 251          {   
 252   1      //  wdp_host_rx_setup(WDP_RX_SUSPEND);          // Set up WDP low power receive mode   
 253   1              
 254   1              usb_wakeup();
 255   1              return APP_NORMAL;
 256   1              CE_LOW();
 257   1              hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);                       // Power up radio
 258   1              
 259   1              RFCKEN = 0;     // disable the radio clock    
 260   1        //  usb_wakeup();   
 261   1       //   return APP_NORMAL;    
 262   1            
 263   1        // Minimize the powerconsumption by powering down the MCU    
 264   1        cklf_gpio_wakeup(0x0000, 0x0000);           // GPIO wakeup off   
 265   1        cklf_rtc_disable();   
 266   1        cklf_rtc_init(0x00, 0x1FFF);                // Setup power down timeout to app. 1 s   
 267   1        cpu_pwr_down();                             // MCU goto sleep   
 268   1                
 269   1        WUF = 0;                                    // Clear WU flag   
 270   1         
 271   1        return APP_SUSP_WE;      
 272   1      } 
 273                  
 274                  void slave_spi() interrupt INTERRUPT_SPI
 275                  {
 276   1               // P0_5 = 1;
 277   1                
 278   1                if(byteCnt==0)
 279   1                {
 280   2                      byteCnt = PKTLENGTH;
 281   2                      block^=0x01; // switch block
 282   2                      blockNeedsSending = 1;
 283   2                }
 284   1              
 285   1                byteCnt = (byteCnt - 1);
 286   1               
 287   1                payload[block][byteCnt] = SSDATA;
 288   1              //  P0_5 = 0;
 289   1              }                               
 290          // Rado interrupt 
 291          void rf_irq() interrupt INTERRUPT_RFIRQ
 292          {
 293   1        uint8_t irq_flags;
 294   1        uint8_t data *pbuf = payload[block];
 295   1        uint8_t data ctr = 0;
 296   1        
 297   1        P0_5=1;
 298   1        // Read and clear IRQ flags from radio
 299   1          CSN_LOW();
 300   1        // retval = hal_nrf_rw(W_REGISTER + reg);
 301   1      
 302   1        RFDAT = W_REGISTER + STATUS;
 303   1        RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
 304   1                        // after data written to RFDAT..
 305   1        while(!RFSPIF); // wait for byte transfer finished
 306   1          
 307   1        irq_flags = RFDAT;   // return SPI read value
 308   1      
 309   1      
 310   1        RFDAT = (BIT_6|BIT_5|BIT_4);
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 60  

 311   1        RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
 312   1                        // after data written to RFDAT..
 313   1        while(!RFSPIF); // wait for byte transfer finished
 314   1          
 315   1        // retval = RFDAT;   // return SPI read value
 316   1      
 317   1       //  hal_nrf_rw(value);
 318   1        CSN_HIGH();                                            
 319   1        irq_flags = irq_flags & (BIT_6|BIT_5|BIT_4);
 320   1       // irq_flags = hal_nrf_get_clear_irq_flags(); 
 321   1        
 322   1      
 323   1        // If data received
 324   1        if(irq_flags & (1<<HAL_NRF_RX_DR))
 325   1        {
 326   2          // Read payload
 327   2         // while(!hal_nrf_rx_fifo_empty())
 328   2         // {
 329   2                   // hal_nrf_read_rx_payload(payload[0]);
 330   2                       //hal_nrf_read_multibyte_reg( (uint8_t)HAL_NRF_RX_PLOAD, payload[0]);
 331   2                      if( (hal_nrf_get_rx_data_source()) < 7)
 332   2                    {
 333   3                      ctr = hal_nrf_read_rx_payload_width();
 334   3                      CSN_LOW();
 335   3                      hal_nrf_rw(R_RX_PAYLOAD);
 336   3                    }
 337   2                    else
 338   2                    {
 339   3                      ctr = 0;
 340   3                    }
 341   2                
 342   2                         
 343   2                       while(ctr--)
 344   2                      {
 345   3                              RFDAT = 0;
 346   3                              RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
 347   3                        // after data written to RFDAT..
 348   3                              while(!RFSPIF); // wait for byte transfer finished
 349   3          
 350   3                        //return RFDAT;   // return SPI read value
 351   3                      *pbuf++ = RFDAT;
 352   3                      }
 353   2      
 354   2                      CSN_HIGH();
 355   2                      
 356   2          // Write received payload[0] to port 0
 357   2      //      P0=(payload[0]&(1<<5));
 358   2                 blockNeedsSending = 1;
 359   2              //}
 360   2              
 361   2        }
 362   1        P0_5=0;
 363   1      }
 364                                                                                                                                                    
 365          static void radio_init()
 366          {
 367   1                // Enable radio SPI
 368   1              RFCTL = 0x10; 
 369   1              /** RF init **/
 370   1              RF = 1;                 // Enable RF interrupt
 371   1              RFCKEN = 1;     // Enable the radio clock
 372   1              hal_nrf_set_operation_mode(HAL_NRF_PRX);                // Configure radio as primary receiver (PRX) 
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 61  

 373   1      //      hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, 30);        // Set payload width to 3 bytes
 374   1      /*      hal_nrf_set_power_mode(HAL_NRF_PWR_UP);                 // Power up radio
 375   1              CE_HIGH();         // Enable receiver 
 376   1      */
 377   1              return;
 378   1      }
 379          
 380          void usb_wakeup(void)   
 381          {   
 382   1        hal_usb_wakeup();
 383   1       // radio_init();   
 384   1        usb_state = USB_AWAKE;   
 385   1      }   
 386             
 387          usb_state_t usb_get_state()   
 388          {   
 389   1        return usb_state;   
 390   1      }
 391          
 392          void usb_wait_for_configuration(void)   
 393          {   
 394   1        volatile hal_usb_state_t usb_hal_state;   
 395   1        do   
 396   1        {   
 397   2          usb_hal_state = hal_usb_get_state();   
 398   2        }   
 399   1        while(usb_hal_state != CONFIGURED);   
 400   1      }
 401          
 402          static hal_usb_dev_req_resp_t device_req_cb(hal_usb_device_req* req, uint8_t** data_ptr, uint16_t* size) r
             -eentrant
 403          {
 404   1              hal_usb_dev_req_resp_t retval;  
 405   1              uint8_t reply[] = "Ping!";
 406   1              
 407   1              *data_ptr = reply;
 408   1              *size = 6;
 409   1              retval = DATA;
 410   1                      
 411   1              return retval;
 412   1      }
*** WARNING C280 IN LINE 402 OF MAIN.C: 'req': unreferenced local variable
 413          
 414          static void suspend_cb(uint8_t allow_remote_wu) reentrant   
 415          {   
 416   1        USBSLP = 1; // Disable USB clock (auto clear)   
 417   1        
 418   1        if (allow_remote_wu == 1)   
 419   1        {   
 420   2          // Enable wake-up on USB and USBWU (bit3:0=1010)   
 421   2          // Enable MCU_WU (bit5:4=10 ) on RTC   
 422   2          WUCONF = (BIT_5 | BIT_3 | BIT_1);   
 423   2          usb_state = USB_REM_WU_ENABLE;   
 424   2        }   
 425   1        else   
 426   1        {   
 427   2          // Enable wake-up on USB and USBWU (bit3:0=1010)   
 428   2          WUCONF = (BIT_3 | BIT_1);   
 429   2          usb_state = USB_REM_WU_DISABLE;   
 430   2        } 
 431   1      }
 432          
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 62  

 433          static void resume_cb() reentrant   
 434          { 
 435   1      //  radio_init();  
 436   1        ep1_sent = true;   
 437   1        usb_state = USB_AWAKE;   
 438   1      }
 439          
 440          static void reset_cb() reentrant   
 441          { 
 442   1      //      radio_init();  
 443   1        ep1_sent = true;  
 444   1        usb_state = USB_AWAKE;    
 445   1      }
 446           
 447          static code uint8_t ep_1_in_cb(uint8_t *adr_ptr, uint8_t* size) reentrant   
 448          {  
 449   1        ep1_sent = true;   
 450   1        return 0x60; // NAK   
 451   1      }
*** WARNING C280 IN LINE 447 OF MAIN.C: 'adr_ptr': unreferenced local variable
*** WARNING C280 IN LINE 447 OF MAIN.C: 'size': unreferenced local variable
 452          
 453          uint8_t ep_1_out_cb( uint8_t xdata *adr_ptr, uint8_t xdata *size) reentrant   
 454          {
 455   1              static uint8_t xdata *buf_ptr;   
 456   1              static uint8_t i = 0; 
 457   1              
 458   1              buf_ptr = CALCULATE_BUF_OUT_PTR(2); 
 459   1              ep2_rx = true;
 460   1              //e_size = *size;
 461   1              // ep2_adr = adr_ptr
 462   1      
 463   1      
 464   1              for(i = 0; i < SIZEOFPROG; ++i)
 465   1              {
 466   2                      ackPayload[i] = buf_ptr[i];
 467   2              }  
 468   1              return 0xff; // clear OUT1 busy   
 469   1      }  
*** WARNING C280 IN LINE 453 OF MAIN.C: 'adr_ptr': unreferenced local variable
*** WARNING C280 IN LINE 453 OF MAIN.C: 'size': unreferenced local variable
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 63  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 95
0000 E4                CLR     A
0001 F500        R     MOV     app_state,A
                                           ; SOURCE LINE # 96
0003 F5A3              MOV     CLKCTL,A
                                           ; SOURCE LINE # 97
0005 75940B            MOV     P0DIR,#0BH
                                           ; SOURCE LINE # 106
0008 C290              CLR     RFCE
                                           ; SOURCE LINE # 107
000A 75E610            MOV     RFCTL,#010H
                                           ; SOURCE LINE # 108
000D D292              SETB    RFCKEN
                                           ; SOURCE LINE # 109
000F D2B9              SETB    RF
                                           ; SOURCE LINE # 113
0011 900000      E     MOV     DPTR,#usbpair
0014 E0                MOVX    A,@DPTR
0015 4401              ORL     A,#01H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0018 900000      E     MOV     DPTR,#?_hal_usb_init?BYTE+04H
001B 74FF              MOV     A,#0FFH
001D F0                MOVX    @DPTR,A
001E A3                INC     DPTR
001F 7400        R     MOV     A,#HIGH _?reset_cb
0021 F0                MOVX    @DPTR,A
0022 A3                INC     DPTR
0023 7400        R     MOV     A,#LOW _?reset_cb
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74FF              MOV     A,#0FFH
0029 F0                MOVX    @DPTR,A
002A A3                INC     DPTR
002B 7400        R     MOV     A,#HIGH _?resume_cb
002D F0                MOVX    @DPTR,A
002E A3                INC     DPTR
002F 7400        R     MOV     A,#LOW _?resume_cb
0031 F0                MOVX    @DPTR,A
0032 A3                INC     DPTR
0033 74FF              MOV     A,#0FFH
0035 F0                MOVX    @DPTR,A
0036 A3                INC     DPTR
0037 7400        R     MOV     A,#HIGH _?suspend_cb
0039 F0                MOVX    @DPTR,A
003A A3                INC     DPTR
003B 7400        R     MOV     A,#LOW _?suspend_cb
003D F0                MOVX    @DPTR,A
003E 7BFF              MOV     R3,#0FFH
0040 7A00        R     MOV     R2,#HIGH _?device_req_cb
0042 7900        R     MOV     R1,#LOW _?device_req_cb
0044 7F01              MOV     R7,#01H
0046 120000      E     LCALL   _hal_usb_init
                                           ; SOURCE LINE # 115
0049 7BFF              MOV     R3,#0FFH
004B 7A00        R     MOV     R2,#HIGH _?ep_1_in_cb
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 64  

004D 7900        R     MOV     R1,#LOW _?ep_1_in_cb
004F 7D20              MOV     R5,#020H
0051 7F82              MOV     R7,#082H
0053 120000      E     LCALL   _hal_usb_endpoint_config
                                           ; SOURCE LINE # 116
0056 7BFF              MOV     R3,#0FFH
0058 7A00        R     MOV     R2,#HIGH _?ep_1_out_cb
005A 7900        R     MOV     R1,#LOW _?ep_1_out_cb
005C 7D20              MOV     R5,#020H
005E 7F02              MOV     R7,#02H
0060 120000      E     LCALL   _hal_usb_endpoint_config
                                           ; SOURCE LINE # 118
0063 900000      R     MOV     DPTR,#ep1_sent
0066 7401              MOV     A,#01H
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
0069 A3                INC     DPTR
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
006B E4                CLR     A
006C F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 123
006E D2AF              SETB    EA
                                           ; SOURCE LINE # 124
0070 120000      R     LCALL   usb_wait_for_configuration
                                           ; SOURCE LINE # 126
0073 750020      R     MOV     byteCnt,#020H
                                           ; SOURCE LINE # 128
0076 7500AA      R     MOV     payload+03FH,#0AAH
                                           ; SOURCE LINE # 129
0079 7500AA      R     MOV     payload+01FH,#0AAH
                                           ; SOURCE LINE # 131
007C         ?C0004:
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 133
007C E500        R     MOV     A,app_state
007E 14                DEC     A
007F 6011              JZ      ?C0008
0081 14                DEC     A
0082 6015              JZ      ?C0010
0084 14                DEC     A
0085 6012              JZ      ?C0010
0087 2403              ADD     A,#03H
0089 70F1              JNZ     ?C0004
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 135
008B         ?C0007:
                                           ; SOURCE LINE # 136
008B 120000      R     LCALL   app_init
008E 8F00        R     MOV     app_state,R7
                                           ; SOURCE LINE # 137
0090 80EA              SJMP    ?C0004
                                           ; SOURCE LINE # 138
0092         ?C0008:
                                           ; SOURCE LINE # 139
0092 120000      R     LCALL   app_normal
0095 8F00        R     MOV     app_state,R7
                                           ; SOURCE LINE # 140
0097 80E3              SJMP    ?C0004
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
0099         ?C0010:
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 65  

                                           ; SOURCE LINE # 144
0099 120000      R     LCALL   app_susp_we
009C 8F00        R     MOV     app_state,R7
                                           ; SOURCE LINE # 146
009E 80DC              SJMP    ?C0004
             ; FUNCTION main (END)

             ; FUNCTION app_normal (BEGIN)
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
0000 120000      R     LCALL   usb_get_state
0003 8F00        R     MOV     temp_state,R7
                                           ; SOURCE LINE # 158
0005 E4                CLR     A
0006 900000      R     MOV     DPTR,#i
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
000A E500        R     MOV     A,temp_state
000C B40103            CJNE    A,#01H,?C0013
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
000F 7F02              MOV     R7,#02H
0011 22                RET     
                                           ; SOURCE LINE # 165
0012         ?C0013:
                                           ; SOURCE LINE # 167
0012 E500        R     MOV     A,temp_state
0014 B40203            CJNE    A,#02H,?C0015
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
0017 7F03              MOV     R7,#03H
0019 22                RET     
                                           ; SOURCE LINE # 170
001A         ?C0015:
                                           ; SOURCE LINE # 172
001A 900000      R     MOV     DPTR,#ep2_rx
001D E0                MOVX    A,@DPTR
001E 600A              JZ      ?C0016
                                           ; SOURCE LINE # 173
                                           ; SOURCE LINE # 174
0020 E4                CLR     A
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 176
0022 7D00        R     MOV     R5,#LOW ackPayload
0024 7B0B              MOV     R3,#0BH
0026 FF                MOV     R7,A
0027 120000      E     LCALL   _hal_nrf_write_ack_payload
                                           ; SOURCE LINE # 178
002A         ?C0016:
                                           ; SOURCE LINE # 180
002A E500        R     MOV     A,blockNeedsSending
002C 6050              JZ      ?C0017
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
002E E4                CLR     A
002F F500        R     MOV     blockNeedsSending,A
                                           ; SOURCE LINE # 185
0031 D285              SETB    P0_5
                                           ; SOURCE LINE # 188
0033 7E00        E     MOV     R6,#HIGH in0buf+0FF00H
0035 7F00        E     MOV     R7,#LOW in0buf+0FF00H
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 66  

;---- Variable 'buf_ptr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 189
0037 7C00        E     MOV     R4,#HIGH in0bc+04H
0039 7D00        E     MOV     R5,#LOW in0bc+04H
;---- Variable 'bc_ptr' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 194
003B         ?C0018:
                                           ; SOURCE LINE # 196
003B E4                CLR     A
003C 900000      R     MOV     DPTR,#i
003F F0                MOVX    @DPTR,A
0040         ?C0019:
                                           ; SOURCE LINE # 197
                                           ; SOURCE LINE # 198
0040 900000      R     MOV     DPTR,#i
0043 E0                MOVX    A,@DPTR
0044 F9                MOV     R1,A
0045 E500        R     MOV     A,block
0047 C4                SWAP    A
0048 33                RLC     A
0049 54E0              ANL     A,#0E0H
004B 2400        R     ADD     A,#LOW payload
004D 29                ADD     A,R1
004E F8                MOV     R0,A
004F E6                MOV     A,@R0
0050 FB                MOV     R3,A
0051 8F82              MOV     DPL,R7
0053 8E83              MOV     DPH,R6
0055 EF                MOV     A,R7
0056 29                ADD     A,R1
0057 F582              MOV     DPL,A
0059 E4                CLR     A
005A 3E                ADDC    A,R6
005B F583              MOV     DPH,A
005D EB                MOV     A,R3
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
005F 900000      R     MOV     DPTR,#i
0062 E0                MOVX    A,@DPTR
0063 04                INC     A
0064 F0                MOVX    @DPTR,A
0065 E0                MOVX    A,@DPTR
0066 B420D7            CJNE    A,#020H,?C0019
0069         ?C0020:
                                           ; SOURCE LINE # 202
0069 8D82              MOV     DPL,R5
006B 8C83              MOV     DPH,R4
006D 7420              MOV     A,#020H
006F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0070 E500        R     MOV     A,block
0072 6005              JZ      ?C0022
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 208
0074 E4                CLR     A
0075 F500        R     MOV     block,A
                                           ; SOURCE LINE # 209
0077 8003              SJMP    ?C0023
0079         ?C0022:
                                           ; SOURCE LINE # 210
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 67  

0079 750001      R     MOV     block,#01H
                                           ; SOURCE LINE # 211
007C         ?C0023:
                                           ; SOURCE LINE # 212
007C C285              CLR     P0_5
                                           ; SOURCE LINE # 218
007E         ?C0017:
                                           ; SOURCE LINE # 220
007E 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 221
0080         ?C0014:
0080 22                RET     
             ; FUNCTION app_normal (END)

             ; FUNCTION app_init (BEGIN)
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 224
                                           ; SOURCE LINE # 225
0000 120000      R     LCALL   usb_get_state
0003 BF0103            CJNE    R7,#01H,?C0024
                                           ; SOURCE LINE # 226
                                           ; SOURCE LINE # 227
0006 7F02              MOV     R7,#02H
0008 22                RET     
                                           ; SOURCE LINE # 228
0009         ?C0024:
                                           ; SOURCE LINE # 230
0009 120000      R     LCALL   usb_get_state
000C BF0203            CJNE    R7,#02H,?C0026
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 232
000F 7F03              MOV     R7,#03H
0011 22                RET     
                                           ; SOURCE LINE # 233
0012         ?C0026:
                                           ; SOURCE LINE # 239
0012 7F01              MOV     R7,#01H
0014 120000      E     LCALL   _hal_nrf_enable_ack_payload
                                           ; SOURCE LINE # 240
0017 7F01              MOV     R7,#01H
0019 120000      E     LCALL   _hal_nrf_enable_dynamic_payload
                                           ; SOURCE LINE # 241
001C 7F01              MOV     R7,#01H
001E 120000      E     LCALL   _hal_nrf_setup_dynamic_payload
                                           ; SOURCE LINE # 242
0021 7F01              MOV     R7,#01H
0023 120000      E     LCALL   _hal_nrf_set_operation_mode
                                           ; SOURCE LINE # 244
0026 7F01              MOV     R7,#01H
0028 120000      E     LCALL   _hal_nrf_set_power_mode
                                           ; SOURCE LINE # 245
002B D290              SETB    RFCE
                                           ; SOURCE LINE # 247
002D 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 248
002F         ?C0025:
002F 22                RET     
             ; FUNCTION app_init (END)

             ; FUNCTION app_susp_we (BEGIN)
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 251
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 68  

                                           ; SOURCE LINE # 254
0000 120000      R     LCALL   usb_wakeup
                                           ; SOURCE LINE # 255
0003 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 269
                                           ; SOURCE LINE # 271
                                           ; SOURCE LINE # 272
0005         ?C0030:
0005 22                RET     
             ; FUNCTION app_susp_we (END)

             ; FUNCTION slave_spi (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0D0              PUSH    PSW
0004 75D000            MOV     PSW,#00H
0007 C000              PUSH    AR0
                                           ; SOURCE LINE # 274
                                           ; SOURCE LINE # 278
0009 E500        R     MOV     A,byteCnt
000B 7009              JNZ     ?C0034
                                           ; SOURCE LINE # 279
                                           ; SOURCE LINE # 280
000D 750020      R     MOV     byteCnt,#020H
                                           ; SOURCE LINE # 281
0010 630001      R     XRL     block,#01H
                                           ; SOURCE LINE # 282
0013 750001      R     MOV     blockNeedsSending,#01H
                                           ; SOURCE LINE # 283
0016         ?C0034:
                                           ; SOURCE LINE # 285
0016 1500        R     DEC     byteCnt
                                           ; SOURCE LINE # 287
0018 E500        R     MOV     A,block
001A C4                SWAP    A
001B 33                RLC     A
001C 54E0              ANL     A,#0E0H
001E 2400        R     ADD     A,#LOW payload
0020 2500        R     ADD     A,byteCnt
0022 F8                MOV     R0,A
0023 A6BD              MOV     @R0,SSDATA
                                           ; SOURCE LINE # 289
0025 D000              POP     AR0
0027 D0D0              POP     PSW
0029 D0E0              POP     ACC
002B 32                RETI    
             ; FUNCTION slave_spi (END)

             ; FUNCTION rf_irq (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 69  

000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 291
                                           ; SOURCE LINE # 294
001D E500        R     MOV     A,block
001F C4                SWAP    A
0020 33                RLC     A
0021 54E0              ANL     A,#0E0H
0023 2400        R     ADD     A,#LOW payload
0025 900000      R     MOV     DPTR,#pbuf
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 295
0029 750000      R     MOV     ctr,#00H
                                           ; SOURCE LINE # 297
002C D285              SETB    P0_5
                                           ; SOURCE LINE # 299
002E C291              CLR     RFCSN
                                           ; SOURCE LINE # 302
0030 75E527            MOV     RFDAT,#027H
                                           ; SOURCE LINE # 303
0033 C2C0              CLR     RFSPIF
0035         ?C0039:
                                           ; SOURCE LINE # 305
0035 30C0FD            JNB     RFSPIF,?C0039
0038         ?C0040:
                                           ; SOURCE LINE # 307
;---- Variable 'irq_flags' assigned to Register 'R7' ----
0038 AFE5              MOV     R7,RFDAT
                                           ; SOURCE LINE # 310
003A 75E570            MOV     RFDAT,#070H
                                           ; SOURCE LINE # 311
003D C2C0              CLR     RFSPIF
003F         ?C0041:
                                           ; SOURCE LINE # 313
003F 30C0FD            JNB     RFSPIF,?C0041
0042         ?C0042:
0042         ?C0045:
                                           ; SOURCE LINE # 318
0042 D291              SETB    RFCSN
                                           ; SOURCE LINE # 319
0044 EF                MOV     A,R7
0045 5470              ANL     A,#070H
0047 FF                MOV     R7,A
                                           ; SOURCE LINE # 324
0048 30E63B            JNB     ACC.6,?C0046
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 331
004B 120000      E     LCALL   hal_nrf_get_rx_data_source
004E EF                MOV     A,R7
004F C3                CLR     C
0050 9407              SUBB    A,#07H
0052 500E              JNC     ?C0047
                                           ; SOURCE LINE # 332
                                           ; SOURCE LINE # 333
0054 120000      E     LCALL   hal_nrf_read_rx_payload_width
0057 8F00        R     MOV     ctr,R7
                                           ; SOURCE LINE # 334
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 70  

0059 C291              CLR     RFCSN
                                           ; SOURCE LINE # 335
005B 7F61              MOV     R7,#061H
005D 120000      E     LCALL   _hal_nrf_rw
                                           ; SOURCE LINE # 336
0060 8003              SJMP    ?C0052
0062         ?C0047:
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
0062 750000      R     MOV     ctr,#00H
                                           ; SOURCE LINE # 340
0065         ?C0052:
                                           ; SOURCE LINE # 343
0065 AF00        R     MOV     R7,ctr
0067 1500        R     DEC     ctr
0069 EF                MOV     A,R7
006A 6015              JZ      ?C0058
                                           ; SOURCE LINE # 344
                                           ; SOURCE LINE # 345
006C 75E500            MOV     RFDAT,#00H
                                           ; SOURCE LINE # 346
006F C2C0              CLR     RFSPIF
0071         ?C0054:
                                           ; SOURCE LINE # 348
0071 30C0FD            JNB     RFSPIF,?C0054
0074         ?C0055:
                                           ; SOURCE LINE # 351
0074 900000      R     MOV     DPTR,#pbuf
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 04                INC     A
007A F0                MOVX    @DPTR,A
007B A807              MOV     R0,AR7
007D A6E5              MOV     @R0,RFDAT
                                           ; SOURCE LINE # 352
007F 80E4              SJMP    ?C0052
0081         ?C0058:
                                           ; SOURCE LINE # 354
0081 D291              SETB    RFCSN
                                           ; SOURCE LINE # 358
0083 750001      R     MOV     blockNeedsSending,#01H
                                           ; SOURCE LINE # 361
0086         ?C0046:
                                           ; SOURCE LINE # 362
0086 C285              CLR     P0_5
                                           ; SOURCE LINE # 363
0088 D007              POP     AR7
008A D006              POP     AR6
008C D005              POP     AR5
008E D004              POP     AR4
0090 D003              POP     AR3
0092 D002              POP     AR2
0094 D001              POP     AR1
0096 D000              POP     AR0
0098 D0D0              POP     PSW
009A D082              POP     DPL
009C D083              POP     DPH
009E D0F0              POP     B
00A0 D0E0              POP     ACC
00A2 32                RETI    
             ; FUNCTION rf_irq (END)

C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 71  

             ; FUNCTION radio_init (BEGIN)
                                           ; SOURCE LINE # 365
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 368
0000 75E610            MOV     RFCTL,#010H
                                           ; SOURCE LINE # 370
0003 D2B9              SETB    RF
                                           ; SOURCE LINE # 371
0005 D292              SETB    RFCKEN
                                           ; SOURCE LINE # 372
0007 7F01              MOV     R7,#01H
0009 120000      E     LCALL   _hal_nrf_set_operation_mode
                                           ; SOURCE LINE # 378
000C         ?C0060:
000C 22                RET     
             ; FUNCTION radio_init (END)

             ; FUNCTION usb_wakeup (BEGIN)
                                           ; SOURCE LINE # 380
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0000 120000      E     LCALL   hal_usb_wakeup
                                           ; SOURCE LINE # 384
0003 E4                CLR     A
0004 F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 385
0006 22                RET     
             ; FUNCTION usb_wakeup (END)

             ; FUNCTION usb_get_state (BEGIN)
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
0000 AF00        R     MOV     R7,usb_state
                                           ; SOURCE LINE # 390
0002         ?C0062:
0002 22                RET     
             ; FUNCTION usb_get_state (END)

             ; FUNCTION usb_wait_for_configuration (BEGIN)
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
0000         ?C0065:
                                           ; SOURCE LINE # 396
                                           ; SOURCE LINE # 397
0000 120000      E     LCALL   hal_usb_get_state
0003 900000      R     MOV     DPTR,#usb_hal_state
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 398
                                           ; SOURCE LINE # 399
0008 E0                MOVX    A,@DPTR
0009 B404F4            CJNE    A,#04H,?C0065
                                           ; SOURCE LINE # 400
000C 22                RET     
             ; FUNCTION usb_wait_for_configuration (END)

             ; FUNCTION _?device_req_cb (BEGIN)
                                           ; SOURCE LINE # 402
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EB                MOV     A,R3
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 72  

0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E9                MOV     A,R1
000D F0                MOVX    @DPTR,A
000E 90FFF9            MOV     DPTR,#0FFF9H
0011 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 405
0014 850083      E     MOV     DPH,?C_XBP
0017 850082      E     MOV     DPL,?C_XBP+01H
001A A3                INC     DPTR
001B A882              MOV     R0,DPL
001D AC83              MOV     R4,DPH
001F 7D01              MOV     R5,#01H
0021 7BFF              MOV     R3,#0FFH
0023 7A00        R     MOV     R2,#HIGH _?ix1000
0025 7900        R     MOV     R1,#LOW _?ix1000
0027 7E00              MOV     R6,#00H
0029 7F06              MOV     R7,#06H
002B 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 407
002E 7B01              MOV     R3,#01H
0030 850083      E     MOV     DPH,?C_XBP
0033 850082      E     MOV     DPL,?C_XBP+01H
0036 A3                INC     DPTR
0037 A982              MOV     R1,DPL
0039 AA83              MOV     R2,DPH
003B C003              PUSH    AR3
003D C002              PUSH    AR2
003F C001              PUSH    AR1
0041 90000A            MOV     DPTR,#0AH
0044 120000      E     LCALL   ?C?XBPOFF
0047 E0                MOVX    A,@DPTR
0048 FB                MOV     R3,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FA                MOV     R2,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E F9                MOV     R1,A
004F 120000      E     LCALL   ?C?PSTPTR
                                           ; SOURCE LINE # 408
0052 90000D            MOV     DPTR,#0DH
0055 120000      E     LCALL   ?C?XBPOFF
0058 E0                MOVX    A,@DPTR
0059 FB                MOV     R3,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C FA                MOV     R2,A
005D A3                INC     DPTR
005E E0                MOVX    A,@DPTR
005F F9                MOV     R1,A
0060 E4                CLR     A
0061 75F006            MOV     B,#06H
0064 120000      E     LCALL   ?C?ISTPTR
                                           ; SOURCE LINE # 409
0067 850083      E     MOV     DPH,?C_XBP
006A 850082      E     MOV     DPL,?C_XBP+01H
006D 7404              MOV     A,#04H
006F F0                MOVX    @DPTR,A
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 73  

                                           ; SOURCE LINE # 411
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
                                           ; SOURCE LINE # 412
0072         ?C0067:
0072 900010            MOV     DPTR,#010H
0075 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?device_req_cb (END)

             ; FUNCTION _?suspend_cb (BEGIN)
                                           ; SOURCE LINE # 414
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 416
0008 75D901            MOV     USBSLP,#01H
                                           ; SOURCE LINE # 418
000B 850083      E     MOV     DPH,?C_XBP
000E 850082      E     MOV     DPL,?C_XBP+01H
0011 E0                MOVX    A,@DPTR
0012 B40108            CJNE    A,#01H,?C0068
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 422
0015 75A52A            MOV     WUCONF,#02AH
                                           ; SOURCE LINE # 423
0018 750001      R     MOV     usb_state,#01H
                                           ; SOURCE LINE # 424
001B 8006              SJMP    ?C0070
001D         ?C0068:
                                           ; SOURCE LINE # 426
                                           ; SOURCE LINE # 428
001D 75A50A            MOV     WUCONF,#0AH
                                           ; SOURCE LINE # 429
0020 750002      R     MOV     usb_state,#02H
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
0023         ?C0070:
0023 900001            MOV     DPTR,#01H
0026 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?suspend_cb (END)

             ; FUNCTION _?resume_cb (BEGIN)
                                           ; SOURCE LINE # 433
                                           ; SOURCE LINE # 436
0000 900000      R     MOV     DPTR,#ep1_sent
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
0006 E4                CLR     A
0007 F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 438
0009 22                RET     
             ; FUNCTION _?resume_cb (END)

             ; FUNCTION _?reset_cb (BEGIN)
                                           ; SOURCE LINE # 440
                                           ; SOURCE LINE # 443
0000 900000      R     MOV     DPTR,#ep1_sent
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 444
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 74  

0006 E4                CLR     A
0007 F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 445
0009 22                RET     
             ; FUNCTION _?reset_cb (END)

             ; FUNCTION _?ep_1_in_cb (BEGIN)
                                           ; SOURCE LINE # 447
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EB                MOV     A,R3
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E9                MOV     A,R1
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
000E 900000      R     MOV     DPTR,#ep1_sent
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 450
0014 7F60              MOV     R7,#060H
                                           ; SOURCE LINE # 451
0016         ?C0073:
0016 900006            MOV     DPTR,#06H
0019 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?ep_1_in_cb (END)

             ; FUNCTION _?ep_1_out_cb (BEGIN)
                                           ; SOURCE LINE # 453
0000 90FFFE            MOV     DPTR,#0FFFEH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EC                MOV     A,R4
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
000B 90FFFE            MOV     DPTR,#0FFFEH
000E 120000      E     LCALL   ?C?ADDXBP
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 458
0016 900000      R     MOV     DPTR,#buf_ptr
0019 7400        E     MOV     A,#HIGH out0buf+0FF00H
001B F0                MOVX    @DPTR,A
001C A3                INC     DPTR
001D 7400        E     MOV     A,#LOW out0buf+0FF00H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 459
0020 900000      R     MOV     DPTR,#ep2_rx
0023 7401              MOV     A,#01H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 464
0026 E4                CLR     A
0027 900000      R     MOV     DPTR,#i
002A F0                MOVX    @DPTR,A
002B         ?C0074:
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 75  

                                           ; SOURCE LINE # 465
                                           ; SOURCE LINE # 466
002B 900000      R     MOV     DPTR,#i
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#buf_ptr
0033 E0                MOVX    A,@DPTR
0034 FC                MOV     R4,A
0035 A3                INC     DPTR
0036 E0                MOVX    A,@DPTR
0037 2F                ADD     A,R7
0038 F582              MOV     DPL,A
003A E4                CLR     A
003B 3C                ADDC    A,R4
003C F583              MOV     DPH,A
003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 7400        R     MOV     A,#LOW ackPayload
0042 2F                ADD     A,R7
0043 F8                MOV     R0,A
0044 A606              MOV     @R0,AR6
                                           ; SOURCE LINE # 467
0046 900000      R     MOV     DPTR,#i
0049 E0                MOVX    A,@DPTR
004A 04                INC     A
004B F0                MOVX    @DPTR,A
004C E0                MOVX    A,@DPTR
004D B40BDB            CJNE    A,#0BH,?C0074
0050         ?C0075:
                                           ; SOURCE LINE # 468
0050 7FFF              MOV     R7,#0FFH
                                           ; SOURCE LINE # 469
0052         ?C0077:
0052 900004            MOV     DPTR,#04H
0055 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?ep_1_out_cb (END)

C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 76  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


hal_nrf_address_t. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_CRC_16BIT. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
ackPayload . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    0000H  11
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
HAL_NRF_0DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CMD_FLASH_SET_PROTECTED. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
STALL. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
e_size . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0003H  1
hal_nrf_address_width_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_hal_usb_endpoint_config . . . . . . .  EXTERN   CODE   PROC     -----  -----
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
rf_irq . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  irq_flags. . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  pbuf . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  1
  ctr. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
cklf_rtc_disable . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
HAL_NRF_6DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DEFAULT. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
hal_usb_get_state. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
APP_SUSP_WD. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_nrf_enable_ack_payload. . . . . .  EXTERN   CODE   PROC     -----  -----
e_arr. . . . . . . . . . . . . . . . .  STATIC   XDATA  PTR      0004H  3
APP_SUSP_WE. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
block. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000BH  1
APP_NORMAL . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_nrf_setup_dynamic_payload . . . .  EXTERN   CODE   PROC     -----  -----
packetizer_t . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  data_ptr . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  data_size. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  pkt_size . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
app_states_t . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PWR_DOWN . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
HAL_NRF_CRC_OFF. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ADDRESSED. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P0_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
USB_REM_WU_DISABLE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
POWERED. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DATA . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
usb_descs_templ_t. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  13
  dev. . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  conf . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0003H  3
  string . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0006H  3
  string_zero. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0009H  4
HAL_NRF_RX_DR. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_ACK_PLOAD. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
cpu_pwr_down . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CMD_FIRMWARE_VERSION . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_dev_req_resp_t . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
RFCE . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
HAL_NRF_TX_DS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 77  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CMD_FLASH_READ . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ep1_sent . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0007H  1
usb_string_desc_templ_t. . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  idx. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
ep2_sent . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0008H  1
usb_state_t. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_usb_cb_endpoint_t. . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_hal_nrf_set_power_mode. . . . . . . .  EXTERN   CODE   PROC     -----  -----
_cklf_gpio_wakeup. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  app_state. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
radio_init . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
_hal_nrf_rw. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CMD_FLASH_WRITE_INIT . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_TX . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_?suspend_cb . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  allow_remote_wu. . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
app_susp_we. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SUSPENDED. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
app_normal . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  temp_state . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  buf_ptr. . . . . . . . . . . . . . .  * REG *  DATA   PTR      0006H  2
  bc_ptr . . . . . . . . . . . . . . .  * REG *  DATA   PTR      0004H  2
usb_conf_desc_templ_t. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  32
  conf . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  9
  if0. . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0009H  9
  ep1in. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0012H  7
  ep1out . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0019H  7
HAL_NRF_AW_3BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_4BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_5BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_12DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
USB_AWAKE. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_t. . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  29
  descs. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  13
  bm_state . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000DH  1
  current_config . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  current_alt_interface. . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  state. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  device_req . . . . . . . . . . . . .  MEMBER   -----  PTR      0011H  3
  reset. . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0014H  3
  resume . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0017H  3
  suspend. . . . . . . . . . . . . . .  MEMBER   -----  PTR      001AH  3
radio_busy . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000CH  1
_?resume_cb. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
HAL_NRF_18DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFCKEN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
hal_usb_state_t. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
usb_wakeup . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
hal_nrf_get_rx_data_source . . . . . .  EXTERN   CODE   PROC     -----  -----
CLKCTL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
ATTACHED . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
blockAcquired. . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000DH  1
hal_usb_conf_desc_t. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 78  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  wTotalLength . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  bNumInterfaces . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  bConfigurationValue. . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  iConfiguration . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  bmAttributes . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  bMaxPower. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
SSDATA . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0000H  6
_?device_req_cb. . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  req. . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  data_ptr . . . . . . . . . . . . . .  AUTO     XDATA  PTR      000AH  3
  size . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      000DH  3
  retval . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  reply. . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0001H  6
_hal_nrf_enable_dynamic_payload. . . .  EXTERN   CODE   PROC     -----  -----
_?ep_1_in_cb . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  adr_ptr. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  size . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0003H  3
CMD_FLASH_SELECT_HALF. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_cb_suspend_t . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
USB_REM_WU_ENABLE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
in0buf . . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  32
HAL_NRF_250KBPS. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_?ep_1_out_cb. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr_ptr. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  2
  size . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0002H  2
  buf_ptr. . . . . . . . . . . . . . .  STATIC   XDATA  PTR      0000H  2
  i. . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0002H  1
out0buf. . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  32
slave_spi. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?reset_cb . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
RFSPIF . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
USBCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
_hal_nrf_set_operation_mode. . . . . .  EXTERN   CODE   PROC     -----  -----
blockNeedsSending. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000EH  1
in0bc. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
_hal_nrf_write_ack_payload . . . . . .  EXTERN   CODE   PROC     -----  -----
HAL_NRF_CRC_8BIT . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ACK. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
usb_state. . . . . . . . . . . . . . .  STATIC   DATA   U_CHAR   000FH  1
ep2_rx . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0009H  1
hal_usb_cb_resume_t. . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
hal_usb_wakeup . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
WUCONF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
hal_nrf_crc_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_ALL. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_irq_source_t . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
app_init . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
hal_nrf_output_power_t . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
NAK. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_dev_desc_t . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  18
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bcdUSB . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 79  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  bDeviceClass . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  bDeviceSubClass. . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  bDeviceProtocol. . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  bMaxPacketSize0. . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  idVendor . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  idProduct. . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  bcdDevice. . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  iManufacturer. . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  iProduct . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  iSerialNumber. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  bNumConfigurations . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
USBSLP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
hal_usb_cb_device_req_t. . . . . . . .  TYPEDEF  -----  PTR      -----  3
byteCnt. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0010H  1
HAL_NRF_PIPE0. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE1. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE2. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_datarate_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PIPE3. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P0DIR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
HAL_NRF_PIPE4. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_device_req . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  bmRequestType. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bRequest . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  wValueMsb. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  wValueLsb. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  wIndex . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  wLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
HAL_NRF_PIPE5. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_1MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_2MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_cklf_rtc_init . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
usb_command_t. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_usb_cb_reset_t . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
EMPTY_RESPONSE . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
S0CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
hal_usb_if_desc_t. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bInterfaceNumber . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  bAlternateSetting. . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  bNumEndpoints. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  bInterfaceClass. . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  bInterfaceSubClass . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  bInterfaceProtocol . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  iInterface . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
CONFIGURED . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_pload_command_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_MAX_RT . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FSR. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
_Bool. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
payload. . . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    0011H  64
usb_wait_for_configuration . . . . . .  STATIC   CODE   PROC     0000H  -----
  usb_hal_state. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
hal_usb_ep_desc_t. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
C51 COMPILER V9.02   MAIN                                                                  05/15/2011 19:16:11 PAGE 80  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bEndpointAddress . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  bmAttributes . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  wMaxPacketSize . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
  bInterval. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
NO_RESPONSE. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
AESCS. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
usb_get_state. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
WUF. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
RFDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
hal_nrf_operation_mode_t . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_nrf_pwr_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CMD_FLASH_ERASE_PAGE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
APP_INIT . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PRX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_usb_init. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RFCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
usbpair. . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
HAL_NRF_RX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PTX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
hal_nrf_read_rx_payload_width. . . . .  EXTERN   CODE   PROC     -----  -----
HAL_NRF_TX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
RFCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
WDCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
IRCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
HAL_NRF_PWR_UP . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFCSN. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    883    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     10       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     81       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
