C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE HAL_NRF_HW
OBJECT MODULE PLACED IN .\hal_nrf_hw.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\hal\nrf24lu1p\hal_nrf_hw.c LARGE BROWSE INCDIR(..\usb_rx;..\..\compil
                    -er\c51;..\..\hal\nrf24lu1p;..\..\hal\nrf24l01p) DEFINE(MCU_NRF24LU1P) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(
                    -.\hal_nrf_hw.lst) PREPRINT(.\hal_nrf_hw.i) OBJECT(.\hal_nrf_hw.obj)

line level    source

   1          /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2           *
   3           * The information contained herein is confidential property of Nordic 
   4           * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5           * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6           *
   7           * Licensees are granted free, non-transferable use of the information. NO
   8           * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9           * the file.
  10           *              
  11           * $LastChangedRevision: 5717 $
  12           */
  13          
  14          /** @file
  15           * @brief Implementation of #hal_nrf_rw for nRF24LU1+
  16           *
  17           * #hal_nrf_rw is an SPI function which is hardware dependent. This file
  18           * contains an implementation for nRF24LU1.
  19           */
  20          
  21          #include <Nordic\reg24lu1.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1   * reg24lu1.h
   3      =1   *
   4      =1   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =1   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =1   *
   7      =1   *
   8      =1   *------------------------------------------------------------------------*/
   9      =1  #ifndef __REG24LU1_H__
  10      =1  #define __REG24LU1_H__
  11      =1  
  12      =1  //-----------------------------------------------------------------------------
  13      =1  // Byte Registers
  14      =1  //-----------------------------------------------------------------------------
  15      =1  
  16      =1  sfr   P0           = 0x80;
  17      =1  sfr   SP           = 0x81;
  18      =1  sfr   DPL          = 0x82;
  19      =1  sfr   DPH          = 0x83;
  20      =1  sfr   DPL1         = 0x84;
  21      =1  sfr   DPH1         = 0x85;
  22      =1  sfr   PCON         = 0x87;
  23      =1  sfr   TCON         = 0x88;
  24      =1  sfr   TMOD         = 0x89;
  25      =1  sfr   TL0          = 0x8A;
  26      =1  sfr   TL1          = 0x8B;
  27      =1  sfr   TH0          = 0x8C;
  28      =1  sfr   TH1          = 0x8D;
  29      =1  sfr   CKCON        = 0x8E;
  30      =1  sfr   RFCON        = 0x90;
  31      =1  sfr   DPS          = 0x92;
  32      =1  sfr   P0DIR        = 0x94;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 2   

  33      =1  sfr   P0ALT        = 0x95;
  34      =1  sfr   S0CON        = 0x98;
  35      =1  sfr   S0BUF        = 0x99;
  36      =1  sfr   IEN2         = 0x9A;
  37      =1  sfr   USBCON       = 0xA0;
  38      =1  sfr   CLKCTL       = 0xA3;
  39      =1  sfr   PWRDWN       = 0xA4;
  40      =1  sfr   WUCONF       = 0xA5;
  41      =1  sfr   INTEXP       = 0xA6;
  42      =1  sfr   IEN0         = 0xA8;
  43      =1  sfr   IP0          = 0xA9;
  44      =1  sfr   S0RELL       = 0xAA;
  45      =1  sfr   REGXH        = 0xAB;
  46      =1  sfr   REGXL        = 0xAC;
  47      =1  sfr   REGXC        = 0xAD;
  48      =1  sfr   RSTRES       = 0xB1;
  49      =1  sfr   SMDAT        = 0xB2;
  50      =1  sfr   SMCTL        = 0xB3;
  51      =1  sfr   TICKDV       = 0xB5;
  52      =1  sfr   IEN1         = 0xB8;
  53      =1  sfr   IP1          = 0xB9;
  54      =1  sfr   S0RELH       = 0xBA;
  55      =1  sfr   SSCONF       = 0xBC;
  56      =1  sfr   SSDATA       = 0xBD;
  57      =1  sfr   SSSTAT       = 0xBE;
  58      =1  sfr   IRCON        = 0xC0;
  59      =1  sfr   CCEN         = 0xC1;
  60      =1  sfr   CCL1         = 0xC2;
  61      =1  sfr   CCH1         = 0xC3;
  62      =1  sfr   CCL2         = 0xC4;
  63      =1  sfr   CCH2         = 0xC5;
  64      =1  sfr   CCL3         = 0xC6;
  65      =1  sfr   CCH3         = 0xC7;
  66      =1  sfr   T2CON        = 0xC8;
  67      =1  sfr   P0EXP        = 0xC9;
  68      =1  sfr   CRCL         = 0xCA;
  69      =1  sfr   CRCH         = 0xCB;
  70      =1  sfr   TL2          = 0xCC;
  71      =1  sfr   TH2          = 0xCD;
  72      =1  sfr   PSW          = 0xD0;
  73      =1  sfr   WDCON        = 0xD8;
  74      =1  sfr   USBSLP       = 0xD9;
  75      =1  sfr   ACC          = 0xE0;
  76      =1  sfr   RFDAT        = 0xE5;
  77      =1  sfr   RFCTL        = 0xE6;
  78      =1  sfr   AESCS        = 0xE8;
  79      =1  sfr   MD0          = 0xE9;
  80      =1  sfr   MD1          = 0xEA;
  81      =1  sfr   MD2          = 0xEB;
  82      =1  sfr   MD3          = 0xEC;
  83      =1  sfr   MD4          = 0xED;
  84      =1  sfr   MD5          = 0xEE;
  85      =1  sfr   ARCON        = 0xEF;
  86      =1  sfr   B            = 0xF0;
  87      =1  sfr   AESKIN       = 0xF1;
  88      =1  sfr   AESIV        = 0xF2;
  89      =1  sfr   AESD         = 0xF3;
  90      =1  sfr   AESIA1       = 0xF5;
  91      =1  sfr   AESIA2       = 0xF6;
  92      =1  sfr   FSR          = 0xF8;
  93      =1  sfr   FPCR         = 0xF9;
  94      =1  sfr   FCR          = 0xFA;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 3   

  95      =1  
  96      =1  //-----------------------------------------------------------------------------
  97      =1  // Word Registers
  98      =1  //-----------------------------------------------------------------------------
  99      =1  
 100      =1  sfr16 CC1          = 0xC2;
 101      =1  sfr16 CC2          = 0xC4;
 102      =1  sfr16 CC3          = 0xC6;
 103      =1  sfr16 CRC          = 0xCA;
 104      =1  sfr16 T2           = 0xCC;
 105      =1  
 106      =1  //-----------------------------------------------------------------------------
 107      =1  /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
 108      =1     This causes errors due to the strong type checking of _Bool (and thereby bool) that
 109      =1     is turned on in our implementation of stdbool.h.
 110      =1     Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
 111      =1  */
 112      =1  
 113      =1  /*lint -e18 */
 114      =1  //-----------------------------------------------------------------------------
 115      =1  
 116      =1  //-----------------------------------------------------------------------------
 117      =1  // Bit Definitions
 118      =1  //-----------------------------------------------------------------------------
 119      =1  
 120      =1  /*  FSR  */
 121      =1  sbit  MCDIS        = FSR^7;
 122      =1  sbit  STP          = FSR^6;
 123      =1  sbit  WEN          = FSR^5;
 124      =1  sbit  RDYN         = FSR^4;
 125      =1  sbit  INFEN        = FSR^3;
 126      =1  sbit  RDIS         = FSR^2;
 127      =1  sbit  RDEND        = FSR^1;
 128      =1  sbit  WPEN         = FSR^0;
 129      =1  
 130      =1  /*  PSW   */
 131      =1  sbit  CY           = PSW^7;
 132      =1  sbit  AC           = PSW^6;
 133      =1  sbit  F0           = PSW^5;
 134      =1  sbit  RS1          = PSW^4;
 135      =1  sbit  RS0          = PSW^3;
 136      =1  sbit  OV           = PSW^2;
 137      =1  sbit  F1           = PSW^1;
 138      =1  sbit  P            = PSW^0;
 139      =1  
 140      =1  /*  TCON  */
 141      =1  sbit  TF1          = TCON^7;
 142      =1  sbit  TR1          = TCON^6;
 143      =1  sbit  TF0          = TCON^5;
 144      =1  sbit  TR0          = TCON^4;
 145      =1  sbit  IE1          = TCON^3;
 146      =1  sbit  IT1          = TCON^2;
 147      =1  sbit  IE0          = TCON^1;
 148      =1  sbit  IT0          = TCON^0;
 149      =1  
 150      =1  /*  S0CON  */
 151      =1  sbit  SM0          = S0CON^7;
 152      =1  sbit  SM1          = S0CON^6;
 153      =1  sbit  SM20         = S0CON^5;
 154      =1  sbit  REN0         = S0CON^4;
 155      =1  sbit  TB80         = S0CON^3;
 156      =1  sbit  RB80         = S0CON^2;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 4   

 157      =1  sbit  TI0          = S0CON^1;
 158      =1  sbit  RI0          = S0CON^0;
 159      =1  
 160      =1  /*  T2CON  */
 161      =1  sbit  T2PS         = T2CON^7;
 162      =1  sbit  I3FR         = T2CON^6;
 163      =1  sbit  I2FR         = T2CON^5;
 164      =1  sbit  T2R1         = T2CON^4;
 165      =1  sbit  T2R0         = T2CON^3;
 166      =1  sbit  T2CM         = T2CON^2;
 167      =1  sbit  T2I1         = T2CON^1;
 168      =1  sbit  T2I0         = T2CON^0;
 169      =1  
 170      =1  /*  IEN0  */
 171      =1  sbit  EA           = IEN0^7;
 172      =1  
 173      =1  sbit  ET2          = IEN0^5;
 174      =1  sbit  ES0          = IEN0^4;
 175      =1  sbit  ET1          = IEN0^3;
 176      =1  sbit  EX1          = IEN0^2;
 177      =1  sbit  ET0          = IEN0^1;
 178      =1  sbit  EX0          = IEN0^0;
 179      =1  
 180      =1  /* IEN1  */
 181      =1  sbit  EXEN2        = IEN1^7;
 182      =1  
 183      =1  sbit  WUIRQ        = IEN1^5;
 184      =1  sbit  USB          = IEN1^4;
 185      =1  sbit  USBWU        = IEN1^3;
 186      =1  sbit  SPI          = IEN1^2;
 187      =1  sbit  RF           = IEN1^1;
 188      =1  sbit  RFSPI        = IEN1^0;
 189      =1  
 190      =1  /* IRCON */
 191      =1  sbit  EXF2         = IRCON^7;
 192      =1  sbit  TF2          = IRCON^6;
 193      =1  sbit  WUF          = IRCON^5;
 194      =1  sbit  USBF         = IRCON^4;
 195      =1  sbit  USBWUF       = IRCON^3;
 196      =1  sbit  SPIF         = IRCON^2;
 197      =1  sbit  RFF          = IRCON^1;
 198      =1  sbit  RFSPIF       = IRCON^0;
 199      =1  
 200      =1  /* USBCON */
 201      =1  sbit  SWRST        = USBCON^7;
 202      =1  sbit  WU           = USBCON^6;
 203      =1  sbit  SUSPEND      = USBCON^5;
 204      =1  sbit  IV4          = USBCON^4;
 205      =1  sbit  IV3          = USBCON^3;
 206      =1  sbit  IV2          = USBCON^2;
 207      =1  sbit  IV1          = USBCON^1;
 208      =1  sbit  IV0          = USBCON^0;
 209      =1  
 210      =1  /* PORT0 */
 211      =1  sbit  P00          = P0^0;
 212      =1  sbit  P01          = P0^1;
 213      =1  sbit  P02          = P0^2;
 214      =1  sbit  P03          = P0^3;
 215      =1  sbit  MCSN         = P0^3;
 216      =1  sbit  SCSN         = P0^3;
 217      =1  sbit  P04          = P0^4;
 218      =1  sbit  P05          = P0^5;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 5   

 219      =1  
 220      =1  /* RFCON */
 221      =1  sbit  RFCE         = RFCON^0;
 222      =1  sbit  RFCSN        = RFCON^1;
 223      =1  sbit  RFCKEN       = RFCON^2;
 224      =1  
 225      =1  /* WDCON */
 226      =1  sbit  BD           = WDCON^7;
 227      =1  
 228      =1  /* AESCS */
 229      =1  sbit  GO           = AESCS^0;
 230      =1  sbit  DECR         = AESCS^1;
 231      =1  
 232      =1  /*lint +e18 */  /* Re-enable Lint warning 18 */
 233      =1  
 234      =1  
 235      =1  /* REGX commands */
 236      =1  #define RWD         0x00
 237      =1  #define WWD         0x08
 238      =1  #define RGTIMER     0x01
 239      =1  #define WGTIMER     0x09
 240      =1  #define RRTCLAT     0x02
 241      =1  #define WRTCLAT     0x0A
 242      =1  #define RRTC        0x03
 243      =1  #define WRTCDIS     0x0B
 244      =1  #define RWSTA0      0x04
 245      =1  #define WWCON0      0x0C
 246      =1  #define RWSTA1      0x05
 247      =1  #define WWCON1      0x0D
 248      =1  
 249      =1  //-----------------------------------------------------------------------------
 250      =1  // Interrupt Vector Definitions
 251      =1  //-----------------------------------------------------------------------------
 252      =1  
 253      =1  #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
 254      =1  #define INTERRUPT_T0           1   // Timer0 Overflow
 255      =1  #define INTERRUPT_AES_RDY      2   // AES ready interrupt
 256      =1  #define INTERRUPT_T1           3   // Timer1 Overflow
 257      =1  #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
 258      =1  #define INTERRUPT_T2           5   // Timer2 Overflow
 259      =1  #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
 260      =1  #define INTERRUPT_RFIRQ        9   // RF interrupt
 261      =1  #define INTERRUPT_SPI          10  // SPI interrupt
 262      =1  #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
 263      =1  #define INTERRUPT_USB_INT      12  // USB interrupt
 264      =1  #define INTERRUPT_WU           13  // Internal wakeup interrupt
 265      =1  
 266      =1  //-----------------------------------------------------------------------------
 267      =1  // Header File Preprocessor Directive
 268      =1  //-----------------------------------------------------------------------------
 269      =1  
 270      =1  #endif
  22          #include <stdint.h>
   1      =1  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =1   * Terms and conditions of usage are described in detail in NORDIC
   5      =1   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 6   

  10      =1   *
  11      =1   * $LastChangedRevision: 4726 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =1   *
  17      =1   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =1   * interpreted in the same way by the compiler. The types here are defined by their
  19      =1   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =1   * between the name and properties of the storage class should be true, regardless of
  21      =1   * the compiler being used.
  22      =1   */
  23      =1  
  24      =1  #ifndef __STDINT_H__
  25      =1  #define __STDINT_H__
  26      =1  
  27      =1  #ifdef __C51__
  28      =1  
  29      =1  typedef unsigned char uint8_t;        ///< 8 bit unsigned int
  30      =1  
  31      =1  typedef signed char int8_t;          ///< 8 bit signed int
  32      =1  
  33      =1  typedef unsigned int uint16_t;        ///< 16 bit unsigned int
  34      =1  
  35      =1  typedef signed int int16_t;          ///< 16 bit signed int
  36      =1  
  37      =1  typedef unsigned long uint32_t;       ///< 32 bit unsigned int
  38      =1  
  39      =1  typedef signed long int32_t;         ///< 32 bit signed int
  40      =1  
  41      =1  #endif // __C51__
  42      =1  
  43      =1  #ifndef NULL
  44      =1  #define NULL (void*)0
  45      =1  #endif
  46      =1  
  47      =1  #endif // __STDINT_H__
  23          #include "hal_nrf.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5717 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface functions for the on-chip radio transceiver. 
  16      =1   */
  17      =1   
  18      =1  /** @defgroup hal_nrf24l01p_hal_nrf RF tranceiver (hal_nrf)
  19      =1   * @{
  20      =1   * @ingroup hal_nrf24l01p
  21      =1   * 
  22      =1   * This is the nRF24L01+ transceiver used in several Nordic Semiconductor devices.
  23      =1   * The transceiver is set up and controlled via an internal SPI interface on the chip. 
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 7   

  24      =1   * The HAL for the radio transceiver hides this SPI interface from the programmer.
  25      =1   *
  26      =1   * The nRF24LE1 uses the same 2.4GHz GFSK RF transceiver with embedded protocol engine 
  27      =1   * (Enhanced ShockBurst&tm;) that is found in the nRF24L01+ single chip RF Transceiver.
  28      =1   *
  29      =1   * The RF Transceiver module is configured and operated through the RF transceiver map. 
  30      =1   * This register map is accessed by the MCU through a dedicated on-chip Serial 
  31      =1   * Peripheral interface (SPI) and is available in all power modes of the RF Transceiver 
  32      =1   * module. The register map contains all configuration registers in the RF Transceiver 
  33      =1   * and is accessible in all operation modes of the transceiver. The radio transceiver 
  34      =1   * HAL hides this register map and the usage of the internal SPI.
  35      =1   * 
  36      =1   * This HAL module contains setup functions for configurating the radio; operation functions 
  37      =1   * for controlling the radio when active and for sending and receiving data; and test 
  38      =1   * functions for setting the radio in test modes.
  39      =1   */
  40      =1  
  41      =1  #ifndef HAL_NRF_H__
  42      =1  #define HAL_NRF_H__
  43      =1  
  44      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 8   

           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  45      =1  #include <stdbool.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 4726 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, ar not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their name indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDBOOL_H__
  25      =2  #define __STDBOOL_H__
  26      =2  
  27      =2  //lint -strong(B,_Bool)
  28      =2  typedef unsigned char _Bool; ///< Boolean type
  29      =2  
  30      =2  #define bool _Bool
  31      =2  #define true 1
  32      =2  #define false 0
  33      =2  #define __bool_true_false_are_defined 1
  34      =2  
  35      =2  #endif // __STDBOOL_H__
  46      =1  
  47      =1  #include "hal_nrf_reg.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 5717 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  @brief Register definitions for nRF24L01+
  16      =2  
  17      =2  @details Header file defining register mapping with bit definitions. 
  18      =2  This file is radio-chip dependent, and are included with the hal_nrf.h
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 9   

  19      =2  
  20      =2  @ingroup hal_nrf24l01p_hal_nrf
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_REG_H__
  24      =2  #define HAL_NRF_REG_H__
  25      =2  
  26      =2  /** @name - Instruction Set - */
  27      =2  //@{
  28      =2  /* nRF24L01 Instruction Definitions */
  29      =2  #define W_REGISTER         0x20  /**< Register write command */
  30      =2  #define R_RX_PAYLOAD       0x61  /**< Read RX payload command */
  31      =2  #define W_TX_PAYLOAD       0xA0  /**< Write TX payload command */
  32      =2  #define FLUSH_TX           0xE1  /**< Flush TX register command */
  33      =2  #define FLUSH_RX           0xE2  /**< Flush RX register command */
  34      =2  #define REUSE_TX_PL        0xE3  /**< Reuse TX payload command */
  35      =2  #define ACTIVATE           0x50  /**< Activate features */
  36      =2  #define R_RX_PL_WID        0x60  /**< Read RX payload command */
  37      =2  #define W_ACK_PAYLOAD      0xA8  /**< Write ACK payload command */
  38      =2  #define W_TX_PAYLOAD_NOACK 0xB0  /**< Write ACK payload command */
  39      =2  #define NOP                0xFF  /**< No Operation command, used for reading status register */
  40      =2  //@}
  41      =2  
  42      =2  /** @name  - Register Memory Map - */
  43      =2  //@{
  44      =2  /* nRF24L01 * Register Definitions * */
  45      =2  #define CONFIG        0x00  /**< nRF24L01 config register */
  46      =2  #define EN_AA         0x01  /**< nRF24L01 enable Auto-Acknowledge register */
  47      =2  #define EN_RXADDR     0x02  /**< nRF24L01 enable RX addresses register */
  48      =2  #define SETUP_AW      0x03  /**< nRF24L01 setup of address width register */
  49      =2  #define SETUP_RETR    0x04  /**< nRF24L01 setup of automatic retransmission register */
  50      =2  #define RF_CH         0x05  /**< nRF24L01 RF channel register */
  51      =2  #define RF_SETUP      0x06  /**< nRF24L01 RF setup register */
  52      =2  #define STATUS        0x07  /**< nRF24L01 status register */
  53      =2  #define OBSERVE_TX    0x08  /**< nRF24L01 transmit observe register */
  54      =2  #define CD            0x09  /**< nRF24L01 carrier detect register */
  55      =2  #define RX_ADDR_P0    0x0A  /**< nRF24L01 receive address data pipe0 */
  56      =2  #define RX_ADDR_P1    0x0B  /**< nRF24L01 receive address data pipe1 */
  57      =2  #define RX_ADDR_P2    0x0C  /**< nRF24L01 receive address data pipe2 */
  58      =2  #define RX_ADDR_P3    0x0D  /**< nRF24L01 receive address data pipe3 */
  59      =2  #define RX_ADDR_P4    0x0E  /**< nRF24L01 receive address data pipe4 */
  60      =2  #define RX_ADDR_P5    0x0F  /**< nRF24L01 receive address data pipe5 */
  61      =2  #define TX_ADDR       0x10  /**< nRF24L01 transmit address */
  62      =2  #define RX_PW_P0      0x11  /**< nRF24L01 \# of bytes in rx payload for pipe0 */
  63      =2  #define RX_PW_P1      0x12  /**< nRF24L01 \# of bytes in rx payload for pipe1 */
  64      =2  #define RX_PW_P2      0x13  /**< nRF24L01 \# of bytes in rx payload for pipe2 */
  65      =2  #define RX_PW_P3      0x14  /**< nRF24L01 \# of bytes in rx payload for pipe3 */
  66      =2  #define RX_PW_P4      0x15  /**< nRF24L01 \# of bytes in rx payload for pipe4 */
  67      =2  #define RX_PW_P5      0x16  /**< nRF24L01 \# of bytes in rx payload for pipe5 */
  68      =2  #define FIFO_STATUS   0x17  /**< nRF24L01 FIFO status register */
  69      =2  #define DYNPD         0x1C  /**< nRF24L01 Dynamic payload setup */
  70      =2  #define FEATURE       0x1D  /**< nRF24L01 Exclusive feature setup */
  71      =2  #define AGC_CONFIG    0x1E  /**< nRF24L01+ AGC configuration register */
  72      =2  
  73      =2  //@}
  74      =2  
  75      =2  /* nRF24L01 related definitions */
  76      =2  /* Interrupt definitions */
  77      =2  /* Operation mode definitions */
  78      =2  
  79      =2  /** An enum describing the radio's irq sources.
  80      =2   *
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 10  

  81      =2   */
  82      =2  typedef enum {
  83      =2      HAL_NRF_MAX_RT = 4,     /**< Max retries interrupt */
  84      =2      HAL_NRF_TX_DS,          /**< TX data sent interrupt */
  85      =2      HAL_NRF_RX_DR           /**< RX data received interrupt */
  86      =2  } hal_nrf_irq_source_t;
  87      =2  
  88      =2  /* Operation mode definitions */
  89      =2  /** An enum describing the radio's power mode.
  90      =2   *
  91      =2   */
  92      =2  typedef enum {
  93      =2      HAL_NRF_PTX,            /**< Primary TX operation */
  94      =2      HAL_NRF_PRX             /**< Primary RX operation */
  95      =2  } hal_nrf_operation_mode_t;
  96      =2  
  97      =2  /** An enum describing the radio's power mode.
  98      =2   *
  99      =2   */
 100      =2  typedef enum {
 101      =2      HAL_NRF_PWR_DOWN,       /**< Device power-down */
 102      =2      HAL_NRF_PWR_UP          /**< Device power-up */
 103      =2  } hal_nrf_pwr_mode_t;
 104      =2  
 105      =2  /** An enum describing the radio's output power mode's.
 106      =2   *
 107      =2   */
 108      =2  typedef enum {
 109      =2      HAL_NRF_18DBM,          /**< Output power set to -18dBm */
 110      =2      HAL_NRF_12DBM,          /**< Output power set to -12dBm */
 111      =2      HAL_NRF_6DBM,           /**< Output power set to -6dBm  */
 112      =2      HAL_NRF_0DBM            /**< Output power set to 0dBm   */
 113      =2  } hal_nrf_output_power_t;
 114      =2  
 115      =2  /** An enum describing the radio's on-air datarate.
 116      =2   *
 117      =2   */
 118      =2  typedef enum {
 119      =2      HAL_NRF_1MBPS,          /**< Datarate set to 1 Mbps  */
 120      =2      HAL_NRF_2MBPS,          /**< Datarate set to 2 Mbps  */
 121      =2      HAL_NRF_250KBPS         /**< Datarate set to 250 kbps*/
 122      =2  } hal_nrf_datarate_t;
 123      =2  
 124      =2  /** An enum describing the radio's CRC mode.
 125      =2   *
 126      =2   */
 127      =2  typedef enum {
 128      =2      HAL_NRF_CRC_OFF,    /**< CRC check disabled */
 129      =2      HAL_NRF_CRC_8BIT,   /**< CRC check set to 8-bit */
 130      =2      HAL_NRF_CRC_16BIT   /**< CRC check set to 16-bit */
 131      =2  } hal_nrf_crc_mode_t;
 132      =2  
 133      =2  /** An enum describing the read/write payload command.
 134      =2   *
 135      =2   */
 136      =2  typedef enum {
 137      =2      HAL_NRF_TX_PLOAD = 7,   /**< TX payload definition */
 138      =2      HAL_NRF_RX_PLOAD,        /**< RX payload definition */
 139      =2      HAL_NRF_ACK_PLOAD
 140      =2  } hal_nrf_pload_command_t;
 141      =2  
 142      =2  /** Structure containing the radio's address map.
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 11  

 143      =2   * Pipe0 contains 5 unique address bytes,
 144      =2   * while pipe[1..5] share the 4 MSB bytes, set in pipe1.
 145      =2   * <p><b> - Remember that the LSB byte for all pipes have to be unique! -</b>
 146      =2   */
 147      =2  // nRF24L01 Address struct
 148      =2  
 149      =2  
 150      =2  //typedef struct {
 151      =2  //   uint8_t p0[5];            /**< Pipe0 address, 5 bytes */
 152      =2  //    uint8_t p1[5];            /**< Pipe1 address, 5 bytes, 4 MSB bytes shared for pipe1 to pipe5 */
 153      =2  //    uint8_t p2[1];            /**< Pipe2 address, 1 byte */
 154      =2  //    uint8_t p3[1];            /**< Pipe3 address, 1 byte */
 155      =2  //   uint8_t p4[1];            /**< Pipe3 address, 1 byte */
 156      =2  //   uint8_t p5[1];            /**< Pipe3 address, 1 byte */
 157      =2  //   uint8_t tx[5];            /**< TX address, 5 byte */
 158      =2  //} hal_nrf_l01_addr_map;
 159      =2  
 160      =2  
 161      =2  /** An enum describing the nRF24L01 pipe addresses and TX address.
 162      =2   *
 163      =2   */
 164      =2  typedef enum {
 165      =2      HAL_NRF_PIPE0,              /**< Select pipe0 */
 166      =2      HAL_NRF_PIPE1,              /**< Select pipe1 */
 167      =2      HAL_NRF_PIPE2,              /**< Select pipe2 */
 168      =2      HAL_NRF_PIPE3,              /**< Select pipe3 */
 169      =2      HAL_NRF_PIPE4,              /**< Select pipe4 */
 170      =2      HAL_NRF_PIPE5,              /**< Select pipe5 */
 171      =2      HAL_NRF_TX,                 /**< Refer to TX address*/
 172      =2      HAL_NRF_ALL = 0xFF          /**< Close or open all pipes*/
 173      =2                                  /**< @see hal_nrf_set_address @see hal_nrf_get_address
 174      =2                                   @see hal_nrf_open_pipe  @see hal_nrf_close_pipe */
 175      =2  } hal_nrf_address_t;
 176      =2  
 177      =2  /** An enum describing the radio's address width.
 178      =2   *
 179      =2   */
 180      =2  typedef enum {
 181      =2      HAL_NRF_AW_3BYTES = 3,      /**< Set address width to 3 bytes */
 182      =2      HAL_NRF_AW_4BYTES,          /**< Set address width to 4 bytes */
 183      =2      HAL_NRF_AW_5BYTES           /**< Set address width to 5 bytes */
 184      =2  } hal_nrf_address_width_t;
 185      =2  
 186      =2  
 187      =2  /** @name CONFIG register bit definitions */
 188      =2  //@{
 189      =2  
 190      =2  #define MASK_RX_DR    6     /**< CONFIG register bit 6 */
 191      =2  #define MASK_TX_DS    5     /**< CONFIG register bit 5 */
 192      =2  #define MASK_MAX_RT   4     /**< CONFIG register bit 4 */
 193      =2  #define EN_CRC        3     /**< CONFIG register bit 3 */
 194      =2  #define CRCO          2     /**< CONFIG register bit 2 */
 195      =2  #define PWR_UP        1     /**< CONFIG register bit 1 */
 196      =2  #define PRIM_RX       0     /**< CONFIG register bit 0 */
 197      =2  //@}
 198      =2  
 199      =2  /** @name RF_SETUP register bit definitions */
 200      =2  //@{
 201      =2  #define PLL_LOCK      4     /**< RF_SETUP register bit 4 */
 202      =2  #define RF_DR         3     /**< RF_SETUP register bit 3 */
 203      =2  #define RF_PWR1       2     /**< RF_SETUP register bit 2 */
 204      =2  #define RF_PWR0       1     /**< RF_SETUP register bit 1 */
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 12  

 205      =2  #define LNA_HCURR     0     /**< RF_SETUP register bit 0 */
 206      =2  //@}
 207      =2  
 208      =2  /* STATUS 0x07 */
 209      =2  /** @name STATUS register bit definitions */
 210      =2  //@{
 211      =2  #define RX_DR         6     /**< STATUS register bit 6 */
 212      =2  #define TX_DS         5     /**< STATUS register bit 5 */
 213      =2  #define MAX_RT        4     /**< STATUS register bit 4 */
 214      =2  #define TX_FULL       0     /**< STATUS register bit 0 */
 215      =2  //@}
 216      =2  
 217      =2  /* FIFO_STATUS 0x17 */
 218      =2  /** @name FIFO_STATUS register bit definitions */
 219      =2  //@{
 220      =2  #define TX_REUSE      6     /**< FIFO_STATUS register bit 6 */
 221      =2  #define TX_FIFO_FULL  5     /**< FIFO_STATUS register bit 5 */
 222      =2  #define TX_EMPTY      4     /**< FIFO_STATUS register bit 4 */
 223      =2  #define RX_FULL       1     /**< FIFO_STATUS register bit 1 */
 224      =2  #define RX_EMPTY      0     /**< FIFO_STATUS register bit 0 */
 225      =2  //@}
 226      =2  
 227      =2  #endif // HAL_NRF_REG_H__
 228      =2  /** @} */
  48      =1  #include "hal_nrf_hw.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 5717 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  * @brief hal_nrf macros for nRF24LU1+
  16      =2   *
  17      =2   * @defgroup hal_nrf24lu1p_hal_nrf_hw hal_nrf_hw
  18      =2   * @{
  19      =2   * @ingroup hal_nrf24lu1p
  20      =2   *
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_LU1_H__
  24      =2  #define HAL_NRF_LU1_H__
  25      =2  
  26      =2  #include <Nordic\reg24lu1.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3   * reg24lu1.h
   3      =3   *
   4      =3   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =3   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =3   *
   7      =3   *
   8      =3   *------------------------------------------------------------------------*/
   9      =3  #ifndef __REG24LU1_H__
           =3 #define __REG24LU1_H__
           =3 
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 13  

           =3 //-----------------------------------------------------------------------------
           =3 // Byte Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 sfr   P0           = 0x80;
           =3 sfr   SP           = 0x81;
           =3 sfr   DPL          = 0x82;
           =3 sfr   DPH          = 0x83;
           =3 sfr   DPL1         = 0x84;
           =3 sfr   DPH1         = 0x85;
           =3 sfr   PCON         = 0x87;
           =3 sfr   TCON         = 0x88;
           =3 sfr   TMOD         = 0x89;
           =3 sfr   TL0          = 0x8A;
           =3 sfr   TL1          = 0x8B;
           =3 sfr   TH0          = 0x8C;
           =3 sfr   TH1          = 0x8D;
           =3 sfr   CKCON        = 0x8E;
           =3 sfr   RFCON        = 0x90;
           =3 sfr   DPS          = 0x92;
           =3 sfr   P0DIR        = 0x94;
           =3 sfr   P0ALT        = 0x95;
           =3 sfr   S0CON        = 0x98;
           =3 sfr   S0BUF        = 0x99;
           =3 sfr   IEN2         = 0x9A;
           =3 sfr   USBCON       = 0xA0;
           =3 sfr   CLKCTL       = 0xA3;
           =3 sfr   PWRDWN       = 0xA4;
           =3 sfr   WUCONF       = 0xA5;
           =3 sfr   INTEXP       = 0xA6;
           =3 sfr   IEN0         = 0xA8;
           =3 sfr   IP0          = 0xA9;
           =3 sfr   S0RELL       = 0xAA;
           =3 sfr   REGXH        = 0xAB;
           =3 sfr   REGXL        = 0xAC;
           =3 sfr   REGXC        = 0xAD;
           =3 sfr   RSTRES       = 0xB1;
           =3 sfr   SMDAT        = 0xB2;
           =3 sfr   SMCTL        = 0xB3;
           =3 sfr   TICKDV       = 0xB5;
           =3 sfr   IEN1         = 0xB8;
           =3 sfr   IP1          = 0xB9;
           =3 sfr   S0RELH       = 0xBA;
           =3 sfr   SSCONF       = 0xBC;
           =3 sfr   SSDATA       = 0xBD;
           =3 sfr   SSSTAT       = 0xBE;
           =3 sfr   IRCON        = 0xC0;
           =3 sfr   CCEN         = 0xC1;
           =3 sfr   CCL1         = 0xC2;
           =3 sfr   CCH1         = 0xC3;
           =3 sfr   CCL2         = 0xC4;
           =3 sfr   CCH2         = 0xC5;
           =3 sfr   CCL3         = 0xC6;
           =3 sfr   CCH3         = 0xC7;
           =3 sfr   T2CON        = 0xC8;
           =3 sfr   P0EXP        = 0xC9;
           =3 sfr   CRCL         = 0xCA;
           =3 sfr   CRCH         = 0xCB;
           =3 sfr   TL2          = 0xCC;
           =3 sfr   TH2          = 0xCD;
           =3 sfr   PSW          = 0xD0;
           =3 sfr   WDCON        = 0xD8;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 14  

           =3 sfr   USBSLP       = 0xD9;
           =3 sfr   ACC          = 0xE0;
           =3 sfr   RFDAT        = 0xE5;
           =3 sfr   RFCTL        = 0xE6;
           =3 sfr   AESCS        = 0xE8;
           =3 sfr   MD0          = 0xE9;
           =3 sfr   MD1          = 0xEA;
           =3 sfr   MD2          = 0xEB;
           =3 sfr   MD3          = 0xEC;
           =3 sfr   MD4          = 0xED;
           =3 sfr   MD5          = 0xEE;
           =3 sfr   ARCON        = 0xEF;
           =3 sfr   B            = 0xF0;
           =3 sfr   AESKIN       = 0xF1;
           =3 sfr   AESIV        = 0xF2;
           =3 sfr   AESD         = 0xF3;
           =3 sfr   AESIA1       = 0xF5;
           =3 sfr   AESIA2       = 0xF6;
           =3 sfr   FSR          = 0xF8;
           =3 sfr   FPCR         = 0xF9;
           =3 sfr   FCR          = 0xFA;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Word Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 sfr16 CC1          = 0xC2;
           =3 sfr16 CC2          = 0xC4;
           =3 sfr16 CC3          = 0xC6;
           =3 sfr16 CRC          = 0xCA;
           =3 sfr16 T2           = 0xCC;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
           =3    This causes errors due to the strong type checking of _Bool (and thereby bool) that
           =3    is turned on in our implementation of stdbool.h.
           =3    Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
           =3 */
           =3 
           =3 /*lint -e18 */
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 /*  FSR  */
           =3 sbit  MCDIS        = FSR^7;
           =3 sbit  STP          = FSR^6;
           =3 sbit  WEN          = FSR^5;
           =3 sbit  RDYN         = FSR^4;
           =3 sbit  INFEN        = FSR^3;
           =3 sbit  RDIS         = FSR^2;
           =3 sbit  RDEND        = FSR^1;
           =3 sbit  WPEN         = FSR^0;
           =3 
           =3 /*  PSW   */
           =3 sbit  CY           = PSW^7;
           =3 sbit  AC           = PSW^6;
           =3 sbit  F0           = PSW^5;
           =3 sbit  RS1          = PSW^4;
           =3 sbit  RS0          = PSW^3;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 15  

           =3 sbit  OV           = PSW^2;
           =3 sbit  F1           = PSW^1;
           =3 sbit  P            = PSW^0;
           =3 
           =3 /*  TCON  */
           =3 sbit  TF1          = TCON^7;
           =3 sbit  TR1          = TCON^6;
           =3 sbit  TF0          = TCON^5;
           =3 sbit  TR0          = TCON^4;
           =3 sbit  IE1          = TCON^3;
           =3 sbit  IT1          = TCON^2;
           =3 sbit  IE0          = TCON^1;
           =3 sbit  IT0          = TCON^0;
           =3 
           =3 /*  S0CON  */
           =3 sbit  SM0          = S0CON^7;
           =3 sbit  SM1          = S0CON^6;
           =3 sbit  SM20         = S0CON^5;
           =3 sbit  REN0         = S0CON^4;
           =3 sbit  TB80         = S0CON^3;
           =3 sbit  RB80         = S0CON^2;
           =3 sbit  TI0          = S0CON^1;
           =3 sbit  RI0          = S0CON^0;
           =3 
           =3 /*  T2CON  */
           =3 sbit  T2PS         = T2CON^7;
           =3 sbit  I3FR         = T2CON^6;
           =3 sbit  I2FR         = T2CON^5;
           =3 sbit  T2R1         = T2CON^4;
           =3 sbit  T2R0         = T2CON^3;
           =3 sbit  T2CM         = T2CON^2;
           =3 sbit  T2I1         = T2CON^1;
           =3 sbit  T2I0         = T2CON^0;
           =3 
           =3 /*  IEN0  */
           =3 sbit  EA           = IEN0^7;
           =3 
           =3 sbit  ET2          = IEN0^5;
           =3 sbit  ES0          = IEN0^4;
           =3 sbit  ET1          = IEN0^3;
           =3 sbit  EX1          = IEN0^2;
           =3 sbit  ET0          = IEN0^1;
           =3 sbit  EX0          = IEN0^0;
           =3 
           =3 /* IEN1  */
           =3 sbit  EXEN2        = IEN1^7;
           =3 
           =3 sbit  WUIRQ        = IEN1^5;
           =3 sbit  USB          = IEN1^4;
           =3 sbit  USBWU        = IEN1^3;
           =3 sbit  SPI          = IEN1^2;
           =3 sbit  RF           = IEN1^1;
           =3 sbit  RFSPI        = IEN1^0;
           =3 
           =3 /* IRCON */
           =3 sbit  EXF2         = IRCON^7;
           =3 sbit  TF2          = IRCON^6;
           =3 sbit  WUF          = IRCON^5;
           =3 sbit  USBF         = IRCON^4;
           =3 sbit  USBWUF       = IRCON^3;
           =3 sbit  SPIF         = IRCON^2;
           =3 sbit  RFF          = IRCON^1;
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 16  

           =3 sbit  RFSPIF       = IRCON^0;
           =3 
           =3 /* USBCON */
           =3 sbit  SWRST        = USBCON^7;
           =3 sbit  WU           = USBCON^6;
           =3 sbit  SUSPEND      = USBCON^5;
           =3 sbit  IV4          = USBCON^4;
           =3 sbit  IV3          = USBCON^3;
           =3 sbit  IV2          = USBCON^2;
           =3 sbit  IV1          = USBCON^1;
           =3 sbit  IV0          = USBCON^0;
           =3 
           =3 /* PORT0 */
           =3 sbit  P00          = P0^0;
           =3 sbit  P01          = P0^1;
           =3 sbit  P02          = P0^2;
           =3 sbit  P03          = P0^3;
           =3 sbit  MCSN         = P0^3;
           =3 sbit  SCSN         = P0^3;
           =3 sbit  P04          = P0^4;
           =3 sbit  P05          = P0^5;
           =3 
           =3 /* RFCON */
           =3 sbit  RFCE         = RFCON^0;
           =3 sbit  RFCSN        = RFCON^1;
           =3 sbit  RFCKEN       = RFCON^2;
           =3 
           =3 /* WDCON */
           =3 sbit  BD           = WDCON^7;
           =3 
           =3 /* AESCS */
           =3 sbit  GO           = AESCS^0;
           =3 sbit  DECR         = AESCS^1;
           =3 
           =3 /*lint +e18 */  /* Re-enable Lint warning 18 */
           =3 
           =3 
           =3 /* REGX commands */
           =3 #define RWD         0x00
           =3 #define WWD         0x08
           =3 #define RGTIMER     0x01
           =3 #define WGTIMER     0x09
           =3 #define RRTCLAT     0x02
           =3 #define WRTCLAT     0x0A
           =3 #define RRTC        0x03
           =3 #define WRTCDIS     0x0B
           =3 #define RWSTA0      0x04
           =3 #define WWCON0      0x0C
           =3 #define RWSTA1      0x05
           =3 #define WWCON1      0x0D
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Interrupt Vector Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
           =3 #define INTERRUPT_T0           1   // Timer0 Overflow
           =3 #define INTERRUPT_AES_RDY      2   // AES ready interrupt
           =3 #define INTERRUPT_T1           3   // Timer1 Overflow
           =3 #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
           =3 #define INTERRUPT_T2           5   // Timer2 Overflow
           =3 #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 17  

           =3 #define INTERRUPT_RFIRQ        9   // RF interrupt
           =3 #define INTERRUPT_SPI          10  // SPI interrupt
           =3 #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
           =3 #define INTERRUPT_USB_INT      12  // USB interrupt
           =3 #define INTERRUPT_WU           13  // Internal wakeup interrupt
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File Preprocessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif
  27      =2  
  28      =2  /** Macro that set radio's CSN line LOW.
  29      =2   *
  30      =2   */
  31      =2  #define CSN_LOW() do { RFCSN = 0; } while(0)
  32      =2  
  33      =2  /** Macro that set radio's CSN line HIGH.
  34      =2   *
  35      =2   */
  36      =2  #define CSN_HIGH() do { RFCSN = 1; } while(0)
  37      =2  
  38      =2  /** Macro that set radio's CE line LOW.
  39      =2   *
  40      =2   */
  41      =2  #define CE_LOW() do { RFCE = 0; } while(0)
  42      =2  
  43      =2  /** Macro that set radio's CE line HIGH.
  44      =2   *
  45      =2   */
  46      =2  #define CE_HIGH() do { RFCE = 1; } while(0)
  47      =2  
  48      =2  /** Macro for writing the radio SPI data register.
  49      =2   *
  50      =2   */
  51      =2  #define HAL_NRF_HW_SPI_WRITE(d) do{RFDAT = d; RFSPIF = 0;} while(0)
  52      =2  
  53      =2  /** Macro for reading the radio SPI data register.
  54      =2   *
  55      =2   */
  56      =2  #define HAL_NRF_HW_SPI_READ() RFDAT
  57      =2    
  58      =2  /** Macro specifyng the radio SPI busy flag.
  59      =2   *
  60      =2   */
  61      =2  #define HAL_NRF_HW_SPI_BUSY (!RFSPIF)
  62      =2  
  63      =2  /**
  64      =2   * Pulses the CE to nRF24L01 for at least 10 us
  65      =2   */
  66      =2  #define CE_PULSE() do { \
  67      =2    uint8_t count; \
  68      =2    count = 20; \
  69      =2    CE_HIGH();  \
  70      =2    while(count--) \
  71      =2      ; \
  72      =2    CE_LOW();  \
  73      =2    } while(0)
  74      =2  
  75      =2  
  76      =2  #endif // HAL_NRF_LU1_H__
  77      =2  
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 18  

  78      =2  /** @} */
  49      =1  
  50      =1  
  51      =1  uint8_t hal_nrf_write_reg(uint8_t data reg, uint8_t data value);
  52      =1  /** @name Setup */
  53      =1  //@{
  54      =1  /* Setup function prototypes */
  55      =1  
  56      =1  /** Enable or disable interrupt for radio.
  57      =1   * Use this function to enable or disable
  58      =1   * one of the interrupt sources for the radio.
  59      =1   * This function only changes state for selected
  60      =1   * int_type, the rest of the interrupt sources
  61      =1   * are left unchanged.
  62      =1   *
  63      =1   * @param int_source Radio interrupt Source.
  64      =1   * @param irq_state Enable or Disable.
  65      =1  */
  66      =1  void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state);
  67      =1  
  68      =1  /* For the obsolete nRF24L01 it is necessary to issue an activate command before the
  69      =1   * features enabled by the FEATURE register can be used. For nRF24L01+ these features
  70      =1   * are by default enabled.
  71      =1  */
  72      =1  void hal_nrf_activate_features(void);
  73      =1  
  74      =1  /** Enables the dynamic packet length
  75      =1   * @param enable Whether enable or disable dynamic packet length
  76      =1   */
  77      =1  void hal_nrf_enable_dynamic_payload(bool enable);
  78      =1  
  79      =1  /** Enables the ACK payload feature
  80      =1   * @param enable Whether to enable or disable ACK payload
  81      =1   */
  82      =1  void hal_nrf_enable_ack_payload(bool enable);
  83      =1  
  84      =1  /** Enables the dynamic ack feature
  85      =1   * @param enable Whether to enable or disable Dynamic ACK
  86      =1   */
  87      =1  void hal_nrf_enable_dynamic_ack(bool enable);
  88      =1  
  89      =1  /** Function for enabling dynmic payload size.
  90      =1   * The input parameter contains is a byte where the bit values tells weather the
  91      =1   * pipe should use dynamic payload size. For example if bit 0 is set then 
  92      =1   * pipe 0 will accept dynamic payload size.
  93      =1   * @param setup Byte value telling for which pips(s) to enable dynamic payload size
  94      =1   */
  95      =1  void hal_nrf_setup_dynamic_payload(uint8_t setup);
  96      =1  
  97      =1  /** Reads the payload width of the received ack payload
  98      =1   * @return Payload width of the received ack payload
  99      =1   */
 100      =1  uint8_t hal_nrf_read_rx_payload_width(void);
 101      =1  
 102      =1  /** Write ack payload
 103      =1   * Writes the payload that will be transmitted with the ack on the given pipe.
 104      =1   * @param pipe Pipe that transmits the payload
 105      =1   * @param tx_pload Pointer to the payload data
 106      =1   * @param length Size of the data to transmit
 107      =1   */
 108      =1  void hal_nrf_write_ack_payload(uint8_t pipe, const uint8_t data *tx_pload, uint8_t data length);
 109      =1  
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 19  

 110      =1  /** Read then clears all interrupt flags.
 111      =1   * Use this function to get the interrupt flags and clear them in the same operation.
 112      =1   * Reduced radio interface activity and speed optimized.
 113      =1   *
 114      =1   * @return  Interrupt_flags
 115      =1   * @retval 0x10 Max Retransmit interrupt
 116      =1   * @retval 0x20 TX Data sent interrupt
 117      =1   * @retval 0x40 RX Data received interrupt
 118      =1  */
 119      =1  uint8_t hal_nrf_get_clear_irq_flags(void);
 120      =1  
 121      =1  /** Clear one selected interrupt flag.
 122      =1   * Use this function to clear one @a spesific interrupt flag.
 123      =1   * Other interrupt flags are left unchanged.
 124      =1   *
 125      =1   * @param int_source Interrupt source of which flag to clear
 126      =1  */
 127      =1  void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source);
 128      =1  
 129      =1  /** Set the CRC mode used by the radio.
 130      =1   * Use this function to set the CRC mode; CRC disabled, 1 or 2 bytes.
 131      =1   *
 132      =1   * @param crc_mode CRC mode to use
 133      =1  */
 134      =1  void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode);
 135      =1  
 136      =1  /** Open radio pipe(s) and enable/ disable auto acknowledge.
 137      =1   * Use this function to open one or all pipes,
 138      =1   * with or without auto acknowledge.
 139      =1   *
 140      =1   * @param pipe_num Radio pipe to open
 141      =1   * @param auto_ack Auto_Ack ON/OFF
 142      =1   * @see hal_nrf_address
 143      =1  */
 144      =1  void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack);
 145      =1  
 146      =1  /** Close radio pipe(s).
 147      =1   * Use this function to close one pipe or all pipes.
 148      =1   *
 149      =1   * @param pipe_num Pipe# number to close
 150      =1  */
 151      =1  void hal_nrf_close_pipe(hal_nrf_address_t pipe_num);
 152      =1  
 153      =1  /** Set radio's RX address and TX address.
 154      =1   * Use this function to set a RX address, or to set the TX address.
 155      =1   * Beware of the difference for single and multibyte address registers.
 156      =1   *
 157      =1   * @param address Which address to set
 158      =1   * @param *addr Buffer from which the address is stored in
 159      =1  */
 160      =1  void hal_nrf_set_address(const hal_nrf_address_t address, const uint8_t *addr);
 161      =1  
 162      =1  /** Get address for selected pipe.
 163      =1   * Use this function to get address for selected pipe.
 164      =1   *
 165      =1   *
 166      =1   * @param address Which address to get, Pipe- or TX-address
 167      =1   * @param *addr buffer in which address bytes are written.
 168      =1   * <BR><BR>For pipes containing only LSB byte of address, this byte is returned
 169      =1   * in the<BR> *addr buffer.
 170      =1   *
 171      =1   * @return Numbers of bytes copied to addr
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 20  

 172      =1  */
 173      =1  uint8_t hal_nrf_get_address (uint8_t address, uint8_t *addr);
 174      =1  
 175      =1  /** Set auto acknowledge parameters.
 176      =1   * Use this function to set retransmit and retransmit delay
 177      =1   * parameters.
 178      =1   *
 179      =1   * @param retr Number of retransmit, 0 equ retransmit OFF
 180      =1   * @param delay Retransmit delay in s. Must be a 
 181      =1  */
 182      =1  void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay);
 183      =1  
 184      =1  /** Set radio's address width.
 185      =1   * Use this function to define the radio's address width,
 186      =1   * referes to both RX and TX.
 187      =1   *
 188      =1   * @param address_width Address with in bytes
 189      =1  */
 190      =1  void hal_nrf_set_address_width(hal_nrf_address_width_t address_width);
 191      =1  
 192      =1  /** Gets the radio's address width.
 193      =1   *
 194      =1   * @return Address width
 195      =1   */
 196      =1  uint8_t hal_nrf_get_address_width (void);
 197      =1  
 198      =1  /** Set payload width for selected pipe.
 199      =1   * Use this function to set the number of bytes expected
 200      =1   * on a selected pipe.
 201      =1   *
 202      =1   * @param pipe_num Pipe number to set payload width for
 203      =1   * @param pload_width number of bytes expected
 204      =1  */
 205      =1  void hal_nrf_set_rx_payload_width(uint8_t pipe_num, uint8_t pload_width);
 206      =1  
 207      =1  /** Read current interrupt mode for selected interrupt source.
 208      =1   * Use this function to get the interrupt source's mode,
 209      =1   * either enabled or disabled.
 210      =1   *
 211      =1   * @param int_source Interrupt source to get mode from
 212      =1   *
 213      =1   * @return Interrupt Mode
 214      =1   * @retval FALSE Interrupt disabled
 215      =1   * @retval TRUE Interrupt enabled
 216      =1  */
 217      =1  bool hal_nrf_get_irq_mode(uint8_t int_source);
 218      =1  
 219      =1  /** Read all interrupt flags.
 220      =1   * Use this function to get the interrupt flags. This function is similar
 221      =1   * to hal_nrf_get_clear_irq_flags with the exception that it does <I><B>NOT</B></I> clear
 222      =1   * the irq_flags.
 223      =1   *
 224      =1   * @return Interrupt_flags
 225      =1   * @retval 0x10 Max Retransmit interrupt
 226      =1   * @retval 0x20 TX Data sent interrupt
 227      =1   * @retval 0x40 RX Data received interrupt
 228      =1  */
 229      =1  uint8_t hal_nrf_get_irq_flags(void);
 230      =1  
 231      =1  /** Get pipe status.
 232      =1   * Use this function to check status for a selected pipe.
 233      =1   *
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 21  

 234      =1   * @param  pipe_num Pipe number to check status for
 235      =1   *
 236      =1   * @return Pipe_Status
 237      =1   * @retval 0x00 Pipe is closed, autoack disabled
 238      =1   * @retval 0x01 Pipe is open, autoack disabled
 239      =1   * @retval 0x03 Pipe is open, autoack enabled
 240      =1  */
 241      =1  uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num);
 242      =1  
 243      =1  /** Get auto retransmit parameters.
 244      =1   * Use this function to get the auto retransmit parameters,
 245      =1   * retrans count and retrans delay.
 246      =1   *
 247      =1   * @return AutoRetrans Parameters
 248      =1   *
 249      =1   * @retval UpperNibble Retransmit Delay
 250      =1   * @retval LowerNibble Retransmit Count
 251      =1  */
 252      =1  uint8_t hal_nrf_get_auto_retr_status(void);
 253      =1  
 254      =1  /** Get packet lost counter
 255      =1   * Use this function to get the packet(s) counter.
 256      =1   *
 257      =1   * @return packet lost counter
 258      =1  */
 259      =1  uint8_t hal_nrf_get_packet_lost_ctr(void);
 260      =1  
 261      =1  /** Get RX payload width for selected pipe.
 262      =1   * Use this function to get the expected payload
 263      =1   * width for selected ppe number.
 264      =1   *
 265      =1   * @param pipe_num Pipe number to get payload width for
 266      =1   *
 267      =1   * @return Payload_Width in bytes                                                                                                                                       
 268      =1  */
 269      =1  uint8_t hal_nrf_get_rx_payload_width(uint8_t pipe_num);
 270      =1  //@}
 271      =1  
 272      =1  /** @name Operation */
 273      =1  //@{
 274      =1  /* Operation function prototypes */
 275      =1  
 276      =1  /** Set radio's operation mode.
 277      =1   * Use this function to enter PTX (primary TX)
 278      =1   * or PRX (primary RX).
 279      =1   *
 280      =1   * @param op_mode Operation mode
 281      =1  */
 282      =1  void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode);
 283      =1  
 284      =1  /** Set radio's power mode.
 285      =1   * Use this function to power_up or power_down radio.
 286      =1   *
 287      =1   * @param pwr_mode POWER_UP or POWER_DOWN
 288      =1  */
 289      =1  void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode);
 290      =1  
 291      =1  /** Set radio's RF channel.
 292      =1   * Use this function to select which RF channel to use.
 293      =1   *
 294      =1   * @param channel RF channel
 295      =1  */
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 22  

 296      =1  void hal_nrf_set_rf_channel(uint8_t channel);
 297      =1  
 298      =1  /** Set radio's TX output power.
 299      =1   * Use this function set the radio's TX output power.
 300      =1   *
 301      =1   * @param power Radio's TX output power
 302      =1  */
 303      =1  void hal_nrf_set_output_power(hal_nrf_output_power_t power);
 304      =1  
 305      =1  /** Set radio's on-air datarate.
 306      =1   * Use this function to select radio's on-air
 307      =1   * datarate.
 308      =1   *
 309      =1   * @param datarate On-air datarate
 310      =1  */
 311      =1  void hal_nrf_set_datarate(hal_nrf_datarate_t datarate);
 312      =1  
 313      =1  
 314      =1  /* Status functions prototypes */
 315      =1  
 316      =1  /** Get radio's TX FIFO status.
 317      =1   * Use this function to get the radio's TX
 318      =1   * FIFO status.
 319      =1   *
 320      =1   * @return TX FIFO status
 321      =1   * @retval 0x00 TX FIFO NOT empty, but NOT full
 322      =1   * @retval 0x01 FIFO empty
 323      =1   * @retval 0x02 FIFO full
 324      =1   *
 325      =1  */
 326      =1  uint8_t hal_nrf_get_tx_fifo_status(void);
 327      =1  
 328      =1  /** Check for TX FIFO empty.
 329      =1   * Use this function to check if TX FIFO
 330      =1   * is empty.
 331      =1   *
 332      =1   * @return TX FIFO empty bit
 333      =1   * @retval FALSE TX FIFO NOT empty
 334      =1   * @retval TRUE TX FIFO empty
 335      =1   *
 336      =1  */
 337      =1  bool hal_nrf_tx_fifo_empty(void);
 338      =1  
 339      =1  /** Check for TX FIFO full.
 340      =1   * Use this function to check if TX FIFO
 341      =1   * is full.
 342      =1   *
 343      =1   * @return TX FIFO full bit
 344      =1   * @retval FALSE TX FIFO NOT full
 345      =1   * @retval TRUE TX FIFO full
 346      =1   *
 347      =1  */
 348      =1  bool hal_nrf_tx_fifo_full(void);
 349      =1  
 350      =1  /** Get radio's RX FIFO status.
 351      =1   * Use this function to get the radio's TX
 352      =1   * FIFO status.
 353      =1   *
 354      =1   * @return RX FIFO status
 355      =1   * @retval 0x00 RX FIFO NOT empty, but NOT full
 356      =1   * @retval 0x01 RX FIFO empty
 357      =1   * @retval 0x02 RX FIFO full
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 23  

 358      =1   *
 359      =1  */
 360      =1  uint8_t hal_nrf_get_rx_fifo_status(void);
 361      =1  
 362      =1  /** Check for RX FIFO empty.
 363      =1   * Use this function to check if RX FIFO
 364      =1   * is empty.
 365      =1   *
 366      =1   * Reads STATUS register to check this, not FIFO_STATUS  
 367      =1   *
 368      =1   * @return RX FIFO empty bit
 369      =1   * @retval FALSE RX FIFO NOT empty
 370      =1   * @retval TRUE RX FIFO empty
 371      =1   *
 372      =1  */
 373      =1  bool hal_nrf_rx_fifo_empty(void);
 374      =1  
 375      =1  /** Check for RX FIFO full.
 376      =1   * Use this function to check if RX FIFO
 377      =1   * is full.
 378      =1   *
 379      =1   * @return RX FIFO full bit
 380      =1   * @retval FALSE RX FIFO NOT full
 381      =1   * @retval TRUE RX FIFO full
 382      =1   *
 383      =1  */
 384      =1  bool hal_nrf_rx_fifo_full(void);
 385      =1  
 386      =1  /** Get radio's transmit attempts status.
 387      =1   * Use this function to get number of retransmit
 388      =1   * attempts and number of packet lost.
 389      =1   *
 390      =1   * @return Retransmit attempts counters
 391      =1  */
 392      =1  uint8_t hal_nrf_get_transmit_attempts(void);
 393      =1  
 394      =1  /** Get the carrier detect flag.
 395      =1   * Use this function to get the carrier detect flag,
 396      =1   * used to detect stationary disturbance on selected
 397      =1   * RF channel.
 398      =1   *
 399      =1   * @return Carrier Detect
 400      =1   * @retval FALSE Carrier NOT Detected
 401      =1   * @retval TRUE Carrier Detected
 402      =1  */
 403      =1  bool hal_nrf_get_carrier_detect(void);
 404      =1  
 405      =1  /* Data operation prototypes */
 406      =1  
 407      =1  /** Get RX data source.
 408      =1   * Use this function to read which RX pipe data
 409      =1   * was received on for current top level FIFO data packet.
 410      =1   *
 411      =1   * @return pipe number of current packet present
 412      =1  */
 413      =1  uint8_t hal_nrf_get_rx_data_source(void);
 414      =1  
 415      =1  /** Read RX payload.
 416      =1   * Use this function to read top level payload
 417      =1   * available in the RX FIFO.
 418      =1   *
 419      =1   * @param  *rx_pload pointer to buffer in which RX payload are stored
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 24  

 420      =1   * @return pipe number (MSB byte) and packet length (LSB byte)
 421      =1  */
 422      =1  
 423      =1  uint16_t hal_nrf_read_rx_payload(uint8_t data *rx_pload);
 424      =1  uint16_t hal_nrf_read_multibyte_reg(uint8_t data reg, uint8_t data *pbuf);
 425      =1  
 426      =1  
 427      =1  /** Write TX payload to radio.
 428      =1   * Use this function to write a packet of
 429      =1   * TX payload into the radio.
 430      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 431      =1   *
 432      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 433      =1   * @param length number of bytes to write
 434      =1  */
 435      =1  void hal_nrf_write_tx_payload(const uint8_t data *tx_pload, uint8_t data length);
 436      =1  
 437      =1  /** Write TX payload which do not require ACK. When transmitting 
 438      =1   * a ACK is not required nor sent from the receiver. The payload will
 439      =1   * always be assumed as "sent".
 440      =1   *
 441      =1   * Use this function to write a packet of
 442      =1   * TX payload into the radio.
 443      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 444      =1   *
 445      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 446      =1   * @param length number of bytes to write
 447      =1  */
 448      =1  void hal_nrf_write_tx_payload_noack(const uint8_t data *tx_pload, uint8_t data length);
 449      =1  
 450      =1  /** Reuse TX payload.
 451      =1   * Use this function to set that the radio is using
 452      =1   * the last transmitted payload for the next packet as well.
 453      =1   *
 454      =1  */
 455      =1  void hal_nrf_reuse_tx(void);
 456      =1  
 457      =1  /** Get status of reuse TX function.
 458      =1   * Use this function to check if reuse TX payload is
 459      =1   * activated
 460      =1   *
 461      =1   * @return Reuse TX payload mode
 462      =1   * @retval FALSE Not activated
 463      =1   * @retval TRUE Activated
 464      =1  */
 465      =1  bool hal_nrf_get_reuse_tx_status(void);
 466      =1  
 467      =1  /** Flush RX FIFO.
 468      =1   * Use this function to flush the radio's
 469      =1   * RX FIFO.
 470      =1   *
 471      =1  */
 472      =1  void hal_nrf_flush_rx(void);
 473      =1  
 474      =1  /** Flush TX FIFO.
 475      =1   * Use this function to flush the radio's
 476      =1   * TX FIFO.
 477      =1   *
 478      =1  */
 479      =1  void hal_nrf_flush_tx(void);
 480      =1  
 481      =1  /** No Operation command.
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 25  

 482      =1   * Use this function to receive the radio's
 483      =1   * status register.
 484      =1   *
 485      =1   * @return Status register
 486      =1  */
 487      =1  uint8_t hal_nrf_nop(void);
 488      =1  //@}
 489      =1  
 490      =1  /** @name  Test */
 491      =1  //@{
 492      =1  /* Test functions prototypes */
 493      =1  
 494      =1  /** Set radio's PLL mode.
 495      =1   * Use this function to either LOCK
 496      =1   * or UNLOCK the radio's PLL.
 497      =1   *
 498      =1   * @param pll_lock PLL locked, TRUE or FALSE
 499      =1  */
 500      =1  void hal_nrf_set_pll_mode(bool pll_lock);
 501      =1  
 502      =1  /** Set radio's LNA gain mode.
 503      =1   * Use this function to either use HI
 504      =1   * current or LOW current mode for the radio.
 505      =1   *
 506      =1   * @param lna_gain LNA gain mode
 507      =1  */
 508      =1  void hal_nrf_set_lna_gain(bool lna_gain);
 509      =1  
 510      =1  /** Enables continuous carrier transmit.
 511      =1   * Use this function to enable or disable
 512      =1   * continuous carrier transmission.
 513      =1   * @param enable Enable continuous carrier
 514      =1   */
 515      =1  void hal_nrf_enable_continious_wave (bool enable);
 516      =1  
 517      =1  /* hal_nrf_l01 basic functions, used by all the other functions */
 518      =1  
 519      =1  //@}
 520      =1  
 521      =1  /** @name SPI interface */
 522      =1  //@{
 523      =1  
 524      =1  /** Basis function, nrf_rw
 525      =1   * This function is used by the basis functions
 526      =1   * to exchange data with the data.
 527      =1   *
 528      =1   * @param value Databyte to write
 529      =1   *
 530      =1   * @return Databyte from radio.
 531      =1  */
 532      =1  uint8_t hal_nrf_rw(uint8_t value);
 533      =1  //@}
 534      =1  #endif // HAL_NRF_H__
 535      =1  /** @} */
 536      =1  
  24          
  25          uint8_t hal_nrf_rw(uint8_t data value)
  26          {
  27   1        RFDAT = value;
  28   1        RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
  29   1                        // after data written to RFDAT..
  30   1        while(!RFSPIF); // wait for byte transfer finished
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 26  

  31   1          
  32   1        return RFDAT;   // return SPI read value
  33   1      }
  34          
  35          
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 27  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _hal_nrf_rw (BEGIN)
                                           ; SOURCE LINE # 25
;---- Variable 'value' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 26
                                           ; SOURCE LINE # 27
0000 8FE5              MOV     RFDAT,R7
                                           ; SOURCE LINE # 28
0002 C2C0              CLR     RFSPIF
0004         ?C0001:
                                           ; SOURCE LINE # 30
0004 30C0FD            JNB     RFSPIF,?C0001
0007         ?C0002:
                                           ; SOURCE LINE # 32
0007 AFE5              MOV     R7,RFDAT
                                           ; SOURCE LINE # 33
0009         ?C0003:
0009 22                RET     
             ; FUNCTION _hal_nrf_rw (END)

C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 28  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


hal_nrf_address_t. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_CRC_16BIT. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
HAL_NRF_0DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_address_width_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
HAL_NRF_6DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
HAL_NRF_PWR_DOWN . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_CRC_OFF. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_RX_DR. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_ACK_PLOAD. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_TX_DS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_nrf_rw. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
HAL_NRF_TX . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_3BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_4BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_5BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_12DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
HAL_NRF_18DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_250KBPS. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFSPIF . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
USBCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
HAL_NRF_CRC_8BIT . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_nrf_crc_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_ALL. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_irq_source_t . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
hal_nrf_output_power_t . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PIPE0. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE1. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE2. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_datarate_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PIPE3. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE4. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE5. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_1MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_2MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
S0CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
hal_nrf_pload_command_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_MAX_RT . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FSR. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
_Bool. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
AESCS. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
RFDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
hal_nrf_operation_mode_t . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_nrf_pwr_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PRX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
HAL_NRF_RX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.02   HAL_NRF_HW                                                            05/15/2011 19:16:12 PAGE 29  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


HAL_NRF_PTX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
HAL_NRF_TX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
WDCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
IRCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
HAL_NRF_PWR_UP . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     10    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
